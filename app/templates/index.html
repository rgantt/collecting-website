<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Collection Manager</title>
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Game Collection">
    <meta name="theme-color" content="#ffffff">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='icons/apple-touch-icon.png') }}">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='icons/favicon-32x32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='icons/favicon-16x16.png') }}">
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <style>
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 25px !important;  
        }
        
        .sortable::after {
            content: '↕';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.3;
            font-size: 0.9em;  
        }
        
        .sortable.sort-asc::after {
            content: '↑';
            opacity: 1;
        }
        
        .sortable.sort-desc::after {
            content: '↓';
            opacity: 1;
        }
        
        @media (max-width: 767.98px) {
            .sortable {
                padding-right: 20px !important;  
            }
            
            .sortable::after {
                right: 4px;  
                font-size: 0.8em;  
            }
            
            .table th {
                font-size: 0.9em;  
            }
        }
        
        .pagination {
            justify-content: center;
            margin-top: 1rem;
        }
        
        .table th {
            white-space: nowrap;
        }
        
        .table {
            table-layout: fixed;
            width: 100%;
        }
        
        /* Mobile-first column widths */
        .name-col {
            width: 75%;
        }
        .console-col {
            width: 25%;
        }
        
        /* Desktop column widths */
        @media (min-width: 768px) {
            .status-col {
                width: 50px;
            }
            .name-col {
                width: 35%;
            }
            .console-col {
                width: 20%;
            }
            .price-col {
                width: 15%;
            }
            .change-col {
                width: 15%;
            }
            .date-col {
                width: 15%;
            }
        }
        
        /* Hide columns on mobile */
        @media (max-width: 767.98px) {
            .d-none.d-md-table-cell,
            .date-col,
            .console-col {
                display: none !important;
            }
            
            /* Ensure name column takes full width on mobile */
            .name-col {
                width: 100% !important;
            }
        }
        
        /* Ensure content truncates properly */
        .table td, .table th {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: middle;
        }
        
        /* Expanded content should stretch full width */
        .expanded-content td {
            white-space: normal;
        }
        
        .game-details {
            display: none;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin: 0.5rem;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .game-details.show {
            display: block;
        }
        
        .game-details dl {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin: 0;
        }
        
        .game-details dl > div {
            flex: 1 1 140px;
            min-width: 140px;
            max-width: 200px;
        }
        
        .game-details dl > div.full-width {
            flex: 1 0 100%;
            max-width: 100%;
        }
        
        .game-details dl > div.full-width dd {
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            max-width: 100%;
        }
        
        .game-details dt {
            font-weight: 600;
            color: #666;
            margin-bottom: 0.25rem;
        }
        
        .game-details dd {
            margin: 0;
        }
        
        @media (max-width: 767.98px) {
            .game-details {
                margin: 0.5rem 0;
            }
            
            .game-details dl {
                gap: 1rem;
            }
            
            .game-details dl > div {
                min-width: 120px;
            }
            
            .details-row td {
                padding: 0 !important;
            }
            
            .details-row .game-details {
                width: 100%;
                border-left: 0;
                border-right: 0;
                border-radius: 0;
            }
        }
        
        .full-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.3;
        }
        
        @media (max-width: 767.98px) {
            .full-name {
                font-size: 1.1rem;
                margin-bottom: 0.75rem;
                padding-bottom: 0.375rem;
            }
        }
        
        .game-row {
            cursor: pointer;
        }
        
        .game-row.selected {
            background-color: #f8f9fa;
        }
        
        #gameDetailsContainer {
            margin-top: 1rem;
        }
        
        .advanced-search-btn:focus {
            box-shadow: none;
        }
        
        #advancedSearch {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            margin-top: 1rem;
        }
        
        /* Main styles */
        body {
            padding-top: 1.5rem;
            padding-bottom: 1.5rem;
        }
        
        /* Lighter placeholder text for better distinction from actual values */
        ::placeholder {
            color: #adb5bd !important;
            opacity: 0.6 !important;
        }
        
        /* For Microsoft browsers */
        ::-ms-input-placeholder {
            color: #adb5bd !important;
            opacity: 0.6 !important;
        }
        
        .sparkline-container {
            width: 100%;
            height: 60px;
            margin-top: 15px;
            margin-bottom: 5px;
        }
        
        /* Add additional margin for y-axis labels */
        .sparkline-chart {
            height: 100%;
            width: 100%;
        }
        
        /* Console dropdown wrapper */
        .console-dropdown-wrapper {
            position: relative;
        }
        
        /* Console dropdown toggle button */
        .console-dropdown-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            text-align: left;
            border: 0;
            cursor: pointer;
            background-image: none !important;
            padding-right: 0.75rem;
        }
        
        .console-dropdown-toggle:focus {
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }
        
        .console-dropdown-arrow {
            transition: transform 0.2s;
        }
        
        .console-dropdown-toggle[aria-expanded="true"] .console-dropdown-arrow {
            transform: rotate(180deg);
        }
        
        /* Console checkbox container styling */
        .console-checkbox-container {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 0.5rem;
            background-color: white;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            margin-top: 0.125rem;
        }
        
        .console-checkbox-container .form-check {
            margin-bottom: 0.25rem;
        }
        
        .console-checkbox-container .form-check:last-child {
            margin-bottom: 0;
        }
        
        /* ===== PHASE 4.1: LOADING STATE IMPROVEMENTS ===== */
        
        /* Subtle loading indicators for background API calls */
        .sync-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: rgba(13, 110, 253, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .sync-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .sync-indicator.success {
            background: rgba(25, 135, 84, 0.9);
        }
        
        .sync-indicator.error {
            background: rgba(220, 53, 69, 0.9);
        }
        
        /* Spinning animation for sync indicator */
        .sync-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Success/Error micro-animations */
        .operation-success {
            animation: pulseGreen 0.6s ease-out;
        }
        
        .operation-error {
            animation: pulseRed 0.6s ease-out;
        }
        
        @keyframes pulseGreen {
            0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); }
            100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); }
        }
        
        @keyframes pulseRed {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        
        /* Fade transitions for smoother updates */
        .game-row {
            transition: all 0.3s ease;
        }
        
        .game-row.updating {
            opacity: 0.7;
            transform: scale(0.99);
        }
        
        .game-row.fade-out {
            opacity: 0;
            transform: scale(0.95);
            transition: all 0.4s ease;
        }
        
        .game-row.fade-in {
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeIn 0.5s ease forwards;
        }
        
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Button loading states */
        .btn-loading {
            position: relative;
            color: transparent !important;
        }
        
        .btn-loading:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .btn-loading.btn-outline-primary:after,
        .btn-loading.btn-outline-secondary:after {
            border-top-color: #0d6efd;
        }
        
        .btn-loading.btn-outline-danger:after {
            border-top-color: #dc3545;
        }
        
        .btn-loading.btn-outline-success:after {
            border-top-color: #198754;
        }
        
        /* Progress indicators for batch operations */
        .batch-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 250px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .batch-progress.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .batch-progress-bar {
            width: 100%;
            height: 4px;
            background-color: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .batch-progress-fill {
            height: 100%;
            background-color: #0d6efd;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        /* Optimistic update visual feedback */
        .optimistic-pending {
            position: relative;
            background-color: rgba(255, 193, 7, 0.1) !important;
            border-left: 3px solid #ffc107;
        }
        
        .optimistic-pending:before {
            content: '';
            position: absolute;
            top: 0;
            left: -3px;
            width: 3px;
            height: 100%;
            background: linear-gradient(45deg, #ffc107 25%, transparent 25%, transparent 75%, #ffc107 75%);
            background-size: 8px 8px;
            animation: slide 1s linear infinite;
        }
        
        @keyframes slide {
            0% { background-position: 0 0; }
            100% { background-position: 8px 8px; }
        }
        
        .optimistic-success {
            background-color: rgba(25, 135, 84, 0.1) !important;
            border-left: 3px solid #198754;
            transition: all 0.5s ease;
        }
        
        .optimistic-error {
            background-color: rgba(220, 53, 69, 0.1) !important;
            border-left: 3px solid #dc3545;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        
        /* Smooth state transitions */
        .state-transition {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Mobile-friendly loading states */
        @media (max-width: 767.98px) {
            .sync-indicator {
                top: 10px;
                right: 10px;
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .batch-progress {
                bottom: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Phase 4.1: Loading State UI Elements -->
    <div id="syncIndicator" class="sync-indicator">
        <span class="sync-spinner"></span>
        <span class="sync-text">Syncing...</span>
    </div>
    
    <div id="batchProgress" class="batch-progress">
        <div class="d-flex justify-content-between align-items-center">
            <span class="batch-progress-text">Refreshing games...</span>
            <span class="batch-progress-count">0/0</span>
        </div>
        <div class="batch-progress-bar">
            <div class="batch-progress-fill" style="width: 0%"></div>
        </div>
    </div>

    <div class="container py-4">
        <div class="card mb-4">
            <div class="card-header">
                <div class="row g-3">
                    <div class="col-md-8">
                        <div class="input-group">
                            <button class="btn btn-outline-primary" type="button" id="addToWishlistBtn" title="Add to Wishlist">
                                <span>+</span>
                            </button>
                            <button class="btn btn-outline-secondary" type="button" id="barcodeScannerBtn" title="Scan Barcode">
                                <span>📷</span>
                            </button>
                            <input type="text" id="searchInput" class="form-control" placeholder="Search games...">
                        </div>
                        <div id="resultCount" class="text-muted mt-1"></div>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-outline-secondary w-100" type="button" id="advancedSearchBtn">
                            Advanced Search
                        </button>
                    </div>
                </div>
                <div class="mt-3" id="advancedSearch" style="display: none;">
                    <div class="row g-3">
                        <div class="col-md-4">
                            <label class="form-label">Console</label>
                            <div class="console-dropdown-wrapper">
                                <button type="button" class="form-select console-dropdown-toggle" id="consoleDropdownToggle">
                                    <span class="console-dropdown-text">All Consoles</span>
                                    <span class="console-dropdown-arrow">▼</span>
                                </button>
                                <div id="consoleFilter" class="console-checkbox-container" style="display: none;">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="consoleAll" checked>
                                        <label class="form-check-label" for="consoleAll">
                                            All Consoles
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Status</label>
                            <select id="statusFilter" class="form-select">
                                <option value="">All Status</option>
                                <option value="owned">Owned</option>
                                <option value="wanted">Wanted</option>
                                <option value="lent">Lent Out</option>
                                <option value="to_sell">To Sell</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Condition</label>
                            <select id="conditionFilter" class="form-select">
                                <option value="">All Conditions</option>
                                <option value="loose">Loose</option>
                                <option value="cib">CIB</option>
                                <option value="new">New</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div class="table-container">
                    <div class="table-responsive">
                        <table id="collectionTable" class="table table-hover">
                            <thead>
                                <tr>
                                    <th class="status-col sortable d-none d-md-table-cell" data-sort="is_wanted" aria-label="Sort by wanted/owned status"></th>
                                    <th class="name-col sortable" data-sort="name">Name</th>
                                    <th class="console-col sortable" data-sort="console">Console</th>
                                    <th class="price-col sortable d-none d-md-table-cell" data-sort="current_price">Price</th>
                                    <th class="change-col sortable d-none d-md-table-cell" data-sort="value_change">Value Change</th>
                                    <th class="date-col sortable d-none d-md-table-cell" data-sort="acquisition_date">Added</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Server-side pagination -->
                <nav id="collectionPagination" aria-label="Collection pagination">
                </nav>
            </div>
        </div>
    </div>

    <div class="container text-center pb-4">
        <a href="/logout" class="btn btn-outline-danger">Logout</a>
    </div>

    <!-- Wishlist/Add Game Dialog -->
    <div class="modal fade" id="wishlistModal" tabindex="-1" aria-labelledby="wishlistModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="wishlistModalLabel">Add Game</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Tab navigation -->
                    <ul class="nav nav-tabs mb-3" id="addGameTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="wishlist-tab" data-bs-toggle="tab" 
                                    data-bs-target="#wishlist-tab-pane" type="button" role="tab" 
                                    aria-controls="wishlist-tab-pane" aria-selected="true">
                                Add to Wishlist
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="purchased-tab" data-bs-toggle="tab" 
                                    data-bs-target="#purchased-tab-pane" type="button" role="tab" 
                                    aria-controls="purchased-tab-pane" aria-selected="false">
                                Add as Purchased
                            </button>
                        </li>
                    </ul>
                    
                    <form id="gameForm">
                        <!-- Common fields for both options -->
                        <div class="mb-3">
                            <label for="pricechartingUrl" class="form-label">Pricecharting.com URL</label>
                            <input type="url" class="form-control" id="pricechartingUrl" 
                                   placeholder="Enter the URL of the game from pricecharting.com (e.g., https://www.pricecharting.com/game/nintendo-switch/mario-tennis-aces)" required>
                            <div class="form-text">Enter the URL of the game from pricecharting.com</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="gameCondition" class="form-label">Condition</label>
                            <select class="form-select" id="gameCondition">
                                <option value="complete" selected>Complete</option>
                                <option value="loose">Loose</option>
                                <option value="new">New</option>
                            </select>
                        </div>
                        
                        <!-- Tab content with conditional fields -->
                        <div class="tab-content" id="addGameTabContent">
                            <!-- Wishlist tab pane (empty, just uses common fields) -->
                            <div class="tab-pane fade show active" id="wishlist-tab-pane" role="tabpanel" 
                                 aria-labelledby="wishlist-tab" tabindex="0">
                                <!-- No additional fields needed for wishlist -->
                            </div>
                            
                            <!-- Purchased tab pane with purchase-specific fields -->
                            <div class="tab-pane fade" id="purchased-tab-pane" role="tabpanel" 
                                 aria-labelledby="purchased-tab" tabindex="0">
                                <div class="mt-3 p-3 border rounded bg-light">
                                    <h6 class="mb-3">Purchase Details</h6>
                                    
                                    <div class="mb-3">
                                        <label for="purchaseDate" class="form-label">Purchase Date</label>
                                        <input type="date" class="form-control" id="purchaseDate" 
                                               value="2025-03-25">
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="purchaseSource" class="form-label">Source</label>
                                        <input type="text" class="form-control" id="purchaseSource" 
                                               placeholder="Where did you purchase this game? (e.g., eBay, GameStop)">
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="purchasePrice" class="form-label">Price</label>
                                        <div class="input-group">
                                            <span class="input-group-text">$</span>
                                            <input type="number" class="form-control" id="purchasePrice" 
                                                   placeholder="Enter purchase price (e.g., 29.99)" step="0.01" min="0">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="formError" class="alert alert-danger d-none mt-3"></div>
                        <div id="formSuccess" class="alert alert-success d-none mt-3"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="submitGameBtn">Add to Wishlist</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Unmark For Sale Confirmation Modal -->
    <div class="modal fade" id="unmarkForSaleModal" tabindex="-1" aria-labelledby="unmarkForSaleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="unmarkForSaleModalLabel">Unmark Game for Sale</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <p>Are you sure you want to remove <strong><span id="unmarkForSaleGameInfo"></span></strong> from your sale list?</p>
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            This will remove the game from your for-sale listings and clear any asking price or sale notes.
                        </div>
                    </div>
                    
                    <div id="unmarkForSaleError" class="alert alert-danger d-none"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-warning" id="confirmUnmarkForSaleBtn">
                        <i class="fas fa-times me-1"></i>Unmark for Sale
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Purchase Modal -->
    <div class="modal fade" id="purchaseModal" tabindex="-1" aria-labelledby="purchaseModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="purchaseModalLabel">Purchase Game</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="purchaseGameInfo" class="mb-3 p-3 border rounded bg-light">
                        <h6 id="purchaseGameName" class="mb-1"></h6>
                        <small id="purchaseGameConsole" class="text-muted"></small>
                    </div>
                    
                    <form id="purchaseForm">
                        <div class="mb-3">
                            <label for="purchaseDateInput" class="form-label">Purchase Date *</label>
                            <input type="date" class="form-control" id="purchaseDateInput" required>
                        </div>
                        
                        <div class="mb-3">
                            <label for="purchaseSourceInput" class="form-label">Source</label>
                            <input type="text" class="form-control" id="purchaseSourceInput" 
                                   placeholder="Where did you purchase this? (e.g., eBay, GameStop, Local Store)">
                        </div>
                        
                        <div class="mb-3">
                            <label for="purchasePriceInput" class="form-label">Price</label>
                            <div class="input-group">
                                <span class="input-group-text">$</span>
                                <input type="number" class="form-control" id="purchasePriceInput" 
                                       placeholder="Enter purchase price" step="0.01" min="0">
                            </div>
                        </div>
                        
                        <div id="purchaseError" class="alert alert-danger d-none mt-3"></div>
                        <div id="purchaseSuccess" class="alert alert-success d-none mt-3"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-success" id="submitPurchaseBtn">📦 Mark as Purchased</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Condition Modal -->
    <div class="modal fade" id="conditionModal" tabindex="-1" aria-labelledby="conditionModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="conditionModalLabel">Edit Game Condition</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="conditionGameInfo" class="mb-3 p-3 border rounded bg-light">
                        <h6 id="conditionGameName" class="mb-1"></h6>
                        <small id="conditionGameConsole" class="text-muted"></small>
                    </div>
                    
                    <form id="conditionForm">
                        <div class="mb-3">
                            <label for="conditionSelect" class="form-label">Condition *</label>
                            <select class="form-select" id="conditionSelect" required>
                                <option value="complete">Complete (Complete in Box)</option>
                                <option value="loose">Loose (Cartridge/Disc Only)</option>
                                <option value="new">New (Sealed)</option>
                            </select>
                        </div>
                        
                        <div id="conditionError" class="alert alert-danger d-none mt-3"></div>
                        <div id="conditionSuccess" class="alert alert-success d-none mt-3"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="submitConditionBtn">Update Condition</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Game Details Modal -->
    <div class="modal fade" id="editDetailsModal" tabindex="-1" aria-labelledby="editDetailsModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editDetailsModalLabel">Edit Game Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="editDetailsGameInfo" class="mb-3 p-3 border rounded bg-light">
                        <h6>Current Details:</h6>
                        <div><strong>Name:</strong> <span id="editDetailsCurrentName"></span></div>
                        <div><strong>Console:</strong> <span id="editDetailsCurrentConsole"></span></div>
                        <div><strong>Condition:</strong> <span id="editDetailsCurrentCondition"></span></div>
                    </div>
                    
                    <form id="editDetailsForm">
                        <div class="mb-3">
                            <label for="editGameName" class="form-label">Game Name *</label>
                            <input type="text" class="form-control" id="editGameName" required 
                                   placeholder="Enter game name">
                        </div>
                        
                        <div class="mb-3">
                            <label for="editGameConsole" class="form-label">Console *</label>
                            <input type="text" class="form-control" id="editGameConsole" required 
                                   placeholder="Enter console name">
                        </div>
                        
                        <div class="mb-3">
                            <label for="editGameCondition" class="form-label">Condition</label>
                            <select class="form-select" id="editGameCondition">
                                <option value="complete">Complete (Complete in Box)</option>
                                <option value="loose">Loose (Cartridge/Disc Only)</option>
                                <option value="new">New (Sealed)</option>
                            </select>
                        </div>
                        
                        <div id="editDetailsError" class="alert alert-danger d-none mt-3"></div>
                        <div id="editDetailsSuccess" class="alert alert-success d-none mt-3"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="submitEditDetailsBtn">Update Details</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Remove from Wishlist Confirmation Modal -->
    <div class="modal fade" id="removeWishlistModal" tabindex="-1" aria-labelledby="removeWishlistModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="removeWishlistModalLabel">Remove from Wishlist</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="removeWishlistGameInfo" class="mb-3 p-3 border rounded bg-light">
                        <h6 id="removeWishlistGameName" class="mb-1"></h6>
                        <small id="removeWishlistGameConsole" class="text-muted"></small>
                    </div>
                    
                    <p class="mb-3">Are you sure you want to remove this game from your wishlist?</p>
                    <p class="text-muted small mb-0">This action cannot be undone. You can always add the game back to your wishlist later if needed.</p>
                    
                    <div id="removeWishlistError" class="alert alert-danger d-none mt-3"></div>
                    <div id="removeWishlistSuccess" class="alert alert-success d-none mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmRemoveWishlistBtn">
                        <i class="fas fa-trash-alt me-1"></i>Remove from Wishlist
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Mark for Sale Modal -->
    <div class="modal fade" id="markForSaleModal" tabindex="-1" aria-labelledby="markForSaleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="markForSaleModalLabel">Mark Game for Sale</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Game:</strong> <span id="markForSaleGameInfo"></span>
                    </div>
                    
                    <div class="mb-3">
                        <label for="askingPriceInput" class="form-label">Asking Price (optional)</label>
                        <div class="input-group">
                            <span class="input-group-text">$</span>
                            <input type="number" class="form-control" id="askingPriceInput" 
                                   placeholder="Enter your asking price" step="0.01" min="0">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="saleNotesInput" class="form-label">Sale Notes (optional)</label>
                        <textarea class="form-control" id="saleNotesInput" rows="3" 
                                  placeholder="Add any notes about the sale (condition details, reason for selling, etc.)"></textarea>
                    </div>
                    
                    <div id="markForSaleError" class="alert alert-danger d-none"></div>
                    <div id="markForSaleSuccess" class="alert alert-success d-none"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-success" id="confirmMarkForSaleBtn">
                        <i class="fas fa-dollar-sign me-1"></i>Mark for Sale
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Mark as Lent Modal -->
    <div class="modal fade" id="markLentModal" tabindex="-1" aria-labelledby="markLentModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="markLentModalLabel">Mark Game as Lent Out</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Game:</strong> <span id="markLentGameInfo"></span>
                    </div>
                    
                    <div class="mb-3">
                        <label for="lentDateInput" class="form-label">Lent Date <span class="text-danger">*</span></label>
                        <input type="date" class="form-control" id="lentDateInput" required>
                    </div>
                    
                    <div class="mb-3">
                        <label for="lentToInput" class="form-label">Lent To <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="lentToInput" 
                               placeholder="Enter person or organization name" required>
                    </div>
                    
                    <div id="markLentError" class="alert alert-danger d-none"></div>
                    <div id="markLentSuccess" class="alert alert-success d-none"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmMarkLentBtn">
                        <i class="fas fa-share me-1"></i>Mark as Lent
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Unmark as Lent Confirmation Modal -->
    <div class="modal fade" id="unmarkLentModal" tabindex="-1" aria-labelledby="unmarkLentModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="unmarkLentModalLabel">Return Game from Lent</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Game:</strong> <span id="unmarkLentGameInfo"></span>
                    </div>
                    <div class="mb-3">
                        <strong>Currently lent to:</strong> <span id="unmarkLentToInfo"></span>
                    </div>
                    
                    <p class="text-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        This will mark the game as returned and remove it from your lent out list.
                    </p>
                    
                    <div id="unmarkLentError" class="alert alert-danger d-none"></div>
                    <div id="unmarkLentSuccess" class="alert alert-success d-none"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmUnmarkLentBtn">
                        <i class="fas fa-undo me-1"></i>Mark as Returned
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Remove from Collection Confirmation Modal -->
    <div class="modal fade" id="removeFromCollectionModal" tabindex="-1" aria-labelledby="removeFromCollectionModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="removeFromCollectionModalLabel">Remove Game from Collection</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Game:</strong> <span id="removeGameInfo"></span>
                    </div>
                    
                    <div class="alert alert-danger">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Warning:</strong> This action will permanently remove this game from your collection. 
                        This will also remove any associated data such as sale status, lent status, and purchase information.
                        <br><br>
                        <strong>This action cannot be undone.</strong>
                    </div>
                    
                    <div id="removeCollectionError" class="alert alert-danger d-none"></div>
                    <div id="removeCollectionSuccess" class="alert alert-success d-none"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmRemoveFromCollectionBtn">
                        <i class="fas fa-trash me-1"></i>Remove from Collection
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Phase 4.2: Conflict Resolution Modal -->
    <div class="modal fade" id="conflictResolutionModal" tabindex="-1" aria-labelledby="conflictResolutionModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="conflictResolutionModalLabel">
                        <i class="fas fa-exclamation-triangle text-warning me-2"></i>
                        Data Conflict Detected
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        The server has different data for this game. Please choose which version to keep:
                    </div>
                    
                    <div id="conflictDetails">
                        <h6 class="fw-bold mb-3">Conflicting Data:</h6>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card border-primary">
                                    <div class="card-header bg-primary text-white">
                                        <i class="fas fa-user me-2"></i>Your Version (Current)
                                    </div>
                                    <div class="card-body" id="currentVersion">
                                        <!-- Current data will be populated here -->
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-success">
                                    <div class="card-header bg-success text-white">
                                        <i class="fas fa-server me-2"></i>Server Version (Latest)
                                    </div>
                                    <div class="card-body" id="serverVersion">
                                        <!-- Server data will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-3">
                            <small class="text-muted">
                                <i class="fas fa-clock me-1"></i>
                                Conflict detected at: <span id="conflictTimestamp"></span>
                            </small>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-times me-1"></i>Cancel
                    </button>
                    <button type="button" class="btn btn-primary" id="keepCurrentBtn">
                        <i class="fas fa-user me-1"></i>Keep My Version
                    </button>
                    <button type="button" class="btn btn-success" id="useServerBtn">
                        <i class="fas fa-server me-1"></i>Use Server Version
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Photo Upload Modal -->
    <div class="modal fade" id="photoUploadModal" tabindex="-1" aria-labelledby="photoUploadModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="photoUploadModalLabel">
                        📸 Add Photos
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="photoUploadGameInfo" class="mb-3 p-3 border rounded bg-light">
                        <h6 id="photoUploadGameName" class="mb-1"></h6>
                        <small id="photoUploadGameConsole" class="text-muted d-block"></small>
                        <small id="photoUploadPhotoCount" class="text-muted"></small>
                    </div>
                    
                    <!-- Photo Upload Section -->
                    <div class="mb-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">Upload New Photos</h6>
                            <small class="text-muted">Max 5MB per photo</small>
                        </div>
                        
                        <!-- Photo Input -->
                        <div class="mb-3">
                            <input type="file" class="form-control" id="photoFiles" 
                                   accept="image/jpeg,image/png,image/webp" multiple
                                   style="display: none;">
                            
                            <!-- Upload Options -->
                            <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                <button type="button" class="btn btn-primary" id="selectFilesBtn">
                                    📁 Select Files
                                </button>
                                <button type="button" class="btn btn-success" id="openCameraBtn" style="display: none;">
                                    📷 Use Camera
                                </button>
                            </div>
                        </div>
                        
                        <!-- Preview Area -->
                        <div id="photoPreviewArea" class="row g-2" style="display: none;">
                            <div class="col-12">
                                <h6 class="text-muted">Selected Photos:</h6>
                            </div>
                        </div>
                        
                        <!-- Upload Progress -->
                        <div id="uploadProgressArea" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small class="text-muted">Uploading photos...</small>
                                <small id="uploadProgressText">0%</small>
                            </div>
                            <div class="progress">
                                <div class="progress-bar" id="uploadProgressBar" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Existing Photos Section -->
                    <div id="existingPhotosSection" style="display: none;">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">Current Photos</h6>
                            <small class="text-muted" id="photoCountBadge">0 photos</small>
                        </div>
                        
                        <div id="existingPhotosList" class="row g-2">
                            <!-- Existing photos will be loaded here -->
                        </div>
                    </div>
                    
                    <div id="photoUploadError" class="alert alert-danger d-none mt-3"></div>
                    <div id="photoUploadSuccess" class="alert alert-success d-none mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="uploadPhotosBtn" disabled>
                        Upload Photos
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Photo Viewer Modal -->
    <div class="modal fade" id="photoViewerModal" tabindex="-1" aria-labelledby="photoViewerModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="photoViewerModalLabel">Photo Viewer</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <img id="photoViewerImage" class="img-fluid" style="max-height: 70vh;" alt="Game Photo">
                    <div class="mt-3">
                        <small class="text-muted" id="photoViewerInfo"></small>
                    </div>
                </div>
                <div class="modal-footer justify-content-between">
                    <div></div> <!-- Empty div for spacing -->
                    <div class="d-flex align-items-center gap-3">
                        <button type="button" class="btn btn-outline-secondary" id="prevPhotoBtn">
                            ← Previous
                        </button>
                        <span class="text-muted" id="photoCounter">1 / 1</span>
                        <button type="button" class="btn btn-outline-secondary" id="nextPhotoBtn">
                            Next →
                        </button>
                    </div>
                    <button type="button" class="btn btn-outline-danger" id="deletePhotoBtn">
                        🗑️ Delete Photo
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Barcode Scanner Modal -->
    <div class="modal fade" id="barcodeScannerModal" tabindex="-1" aria-labelledby="barcodeScannerModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="barcodeScannerModalLabel">📷 Scan Barcode</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body text-center">
                    <!-- Camera Feed -->
                    <div id="cameraContainer" style="position: relative; max-width: 100%; margin: 0 auto;">
                        <video id="barcodeVideo" style="width: 100%; max-width: 500px; height: auto;" autoplay muted playsinline></video>
                        
                        <!-- Scanning Overlay -->
                        <div id="scanningOverlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                                        border: 2px solid #28a745; width: 80%; height: 100px; 
                                                        background: rgba(40, 167, 69, 0.1); display: none;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                       color: #28a745; font-weight: bold;">Point camera at barcode</div>
                        </div>
                    </div>
                    
                    <!-- Status Messages -->
                    <div id="scannerStatus" class="mt-3">
                        <div id="scannerLoading" class="text-muted">Loading camera...</div>
                        <div id="scannerReady" class="text-success" style="display: none;">Point camera at barcode to scan</div>
                        <div id="scannerError" class="text-danger" style="display: none;"></div>
                        <div id="scannerSuccess" class="text-success" style="display: none;"></div>
                    </div>
                    
                    <!-- Manual Entry Option -->
                    <div id="manualEntryOption" class="mt-3" style="display: none;">
                        <p class="text-muted">Camera not available? Enter barcode manually:</p>
                        <div class="input-group">
                            <input type="text" id="manualBarcodeInput" class="form-control" placeholder="Enter UPC/EAN barcode">
                            <button class="btn btn-primary" id="manualBarcodeSubmit">Search</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="manualEntryBtn">Enter Manually</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Barcode Search Results Modal -->
    <div class="modal fade" id="barcodeResultsModal" tabindex="-1" aria-labelledby="barcodeResultsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="barcodeResultsModalLabel">🎮 Barcode Search Results</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="barcodeResultsContent">
                        <!-- Search results will be populated here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Barcode Scanning Library -->
    <script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
    
    <!-- JavaScript Dependencies -->
    <script src="{{ url_for('static', filename='js/state-manager.js') }}"></script>
    <script src="{{ url_for('static', filename='js/error-handler.js') }}"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Initializing collection manager...');
            
            // Add global testing functions for validation
            window.testPhase1 = {
                // Test state manager
                testStateManager: function() {
                    console.log('🧪 Testing GameStateManager...');
                    const testGame = { id: 'test-1', name: 'Test Game', console: 'Test Console' };
                    
                    // Test adding game
                    window.gameStateManager.addGame(testGame);
                    const retrieved = window.gameStateManager.getGame('test-1');
                    
                    if (retrieved && retrieved.name === 'Test Game') {
                        console.log('✅ State manager add/get working');
                    } else {
                        console.error('❌ State manager add/get failed');
                    }
                    
                    // Test pending operations
                    window.gameStateManager.setPendingOperation('test-1', 'test_operation', { test: true });
                    const pending = window.gameStateManager.getPendingOperation('test-1');
                    
                    if (pending && pending.operation === 'test_operation') {
                        console.log('✅ Pending operations working');
                    } else {
                        console.error('❌ Pending operations failed');
                    }
                    
                    // Clean up
                    window.gameStateManager.removeGame('test-1');
                    console.log('🧹 Test cleanup complete');
                },
                
                // Test error handler toasts
                testErrorHandler: function() {
                    console.log('🧪 Testing ErrorHandler toasts...');
                    window.errorHandler.showSuccessToast('Success test! ✅');
                    setTimeout(() => window.errorHandler.showWarningToast('Warning test! ⚠️'), 1000);
                    setTimeout(() => window.errorHandler.showErrorToast('Error test! ❌'), 2000);
                    setTimeout(() => window.errorHandler.showInfoToast('Info test! ℹ️'), 3000);
                },
                
                // Test optimistic updater (basic)
                testOptimisticUpdater: function() {
                    console.log('🧪 Testing OptimisticUpdater basic functionality...');
                    const stats = window.optimisticUpdater.getStats();
                    console.log('📊 OptimisticUpdater stats:', stats);
                    
                    if (typeof window.optimisticUpdater.applyOptimisticUpdate === 'function') {
                        console.log('✅ OptimisticUpdater methods available');
                    } else {
                        console.error('❌ OptimisticUpdater methods missing');
                    }
                },
                
                // Run all tests
                runAllTests: function() {
                    console.log('🚀 Running all Phase 1 tests...');
                    this.testStateManager();
                    this.testOptimisticUpdater();
                    setTimeout(() => this.testErrorHandler(), 500);
                    console.log('✨ All tests complete! Check console output above.');
                }
            };
            
            console.log('🔧 Test functions available: window.testPhase1.runAllTests()');
            console.log('📊 Infrastructure stats available: window.gameStateManager.getStats()');
            
            // Initialize arrays - make allGames global for optimistic updates
            window.allGames = [];
            let filteredGames = [];
            let collectionTotals = null;
            const ITEMS_PER_PAGE = 30;

            // Show loading state
            function showLoading() {
                const tbody = document.querySelector('#collectionTable tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="6" class="text-center">Loading games...</td></tr>';
                }
            }

            // Load all games from API
            async function loadAllGames() {
                try {
                    showLoading();
                    console.log('Loading all games from API...');
                    const response = await fetch('/api/collection');
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    const data = await response.json();
                    window.allGames = data.games || data; // Handle both old and new format
                    collectionTotals = data.totals || null;
                    filteredGames = [...window.allGames];
                    console.log('Loaded games from API:', window.allGames.length);
                    console.log('Collection totals:', collectionTotals);
                    renderGames(window.allGames, true, 1);
                } catch (error) {
                    console.error('Error loading games:', error);
                    const tbody = document.querySelector('#collectionTable tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="6" class="text-center text-danger">Error loading games. Please check your connection and try searching again.</td></tr>';
                    }
                }
            }
            
            // Generate pagination HTML
            function generatePaginationHTML(currentPage, totalPages) {
                if (totalPages <= 1) return ''; // Don't show pagination if only one page
                
                let pages = new Set(); // Use Set to avoid duplicates
                
                // Always add first and last pages
                pages.add(1);
                pages.add(totalPages);
                
                // Add current page and one page on either side
                for (let i = currentPage - 1; i <= currentPage + 1; i++) {
                    if (i > 1 && i < totalPages) {  // Don't add first/last pages again
                        pages.add(i);
                    }
                }
                
                // Convert to sorted array
                let pageArray = Array.from(pages).sort((a, b) => a - b);
                
                // Add ellipses where needed
                let finalPages = [];
                for (let i = 0; i < pageArray.length; i++) {
                    if (i > 0 && pageArray[i] > pageArray[i-1] + 1) {
                        finalPages.push('...');
                    }
                    finalPages.push(pageArray[i]);
                }
                
                return `
                    <ul class="pagination justify-content-center">
                        <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                            <a class="page-link" href="#" data-page="${currentPage - 1}">Previous</a>
                        </li>
                        ${finalPages.map(page => {
                            if (page === '...') {
                                return '<li class="page-item disabled"><span class="page-link">...</span></li>';
                            }
                            return `
                                <li class="page-item ${page === currentPage ? 'active' : ''}">
                                    <a class="page-link" href="#" data-page="${page}">${page}</a>
                                </li>
                            `;
                        }).join('')}
                        <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                            <a class="page-link" href="#" data-page="${currentPage + 1}">Next</a>
                        </li>
                    </ul>
                `;
            }
            
            // Format currency
            window.formatCurrency = function(value) {
                if (value === null || value === undefined || isNaN(value)) return '-';
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
            }
            
            // Format value change percentage
            window.formatValueChange = function(current, purchase) {
                if (!current || !purchase) return '-';
                
                const change = (current - purchase) / purchase * 100;
                const formattedChange = change.toFixed(1);
                const sign = change >= 0 ? '+' : '';
                const color = change >= 0 ? 'success' : 'danger';
                
                return `<span class="text-${color}">${sign}${formattedChange}%</span>`;
            }
            
            // Filter games
            // Make filterGames global so optimistic updates can use it
            window.filterGames = function(games, searchTerm) {
                // Get selected console filters
                const allConsolesChecked = document.getElementById('consoleAll').checked;
                const selectedConsoles = [];
                
                if (!allConsolesChecked) {
                    // Get all checked individual console checkboxes
                    const consoleCheckboxes = document.querySelectorAll('#consoleFilter input[type="checkbox"]:not(#consoleAll)');
                    consoleCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedConsoles.push(checkbox.value);
                        }
                    });
                }
                
                const statusFilter = document.getElementById('statusFilter').value;
                const conditionFilter = document.getElementById('conditionFilter').value.toLowerCase();
                
                return games.filter(game => {
                    const matchesSearch = !searchTerm || 
                        game.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        game.console.toLowerCase().includes(searchTerm.toLowerCase());
                    
                    // Console filter: show all if "All Consoles" is checked, or if game's console matches any selected console
                    const matchesConsole = allConsolesChecked || selectedConsoles.length === 0 || 
                        selectedConsoles.includes(game.console.toLowerCase());
                    
                    const matchesStatus = !statusFilter || 
                        (statusFilter === 'owned' && !game.is_wanted && !game.is_lent && !game.is_for_sale) ||
                        (statusFilter === 'wanted' && game.is_wanted) ||
                        (statusFilter === 'lent' && game.is_lent) ||
                        (statusFilter === 'to_sell' && game.is_for_sale);
                    
                    const matchesCondition = !conditionFilter || 
                        (game.condition && game.condition.toLowerCase() === conditionFilter);
                    
                    return matchesSearch && matchesConsole && matchesStatus && matchesCondition;
                });
            }; // End of window.filterGames function
            
            // Get current page of games
            function getCurrentPageGames(games, page) {
                const startIndex = (page - 1) * ITEMS_PER_PAGE;
                return games.slice(startIndex, startIndex + ITEMS_PER_PAGE);
            }
            
            // Render games with pagination
            // Make renderGames global so optimistic updates can use it
            window.renderGames = function(games, preserveFilteredGames = false, page = 1) {
                console.log('Rendering games:', games.length);
                const tbody = document.querySelector('#collectionTable tbody');
                if (!tbody) {
                    console.error('Collection table body not found!');
                    return;
                }

                // Store filtered games if this is a new filter operation
                if (!preserveFilteredGames) {
                    console.log('Updating filtered games array');
                    filteredGames = [...games];
                }

                // Calculate pagination
                const itemsPerPage = 30;
                const totalPages = Math.ceil(games.length / itemsPerPage);
                const startIndex = (page - 1) * itemsPerPage;
                const endIndex = Math.min(startIndex + itemsPerPage, games.length);
                const pageGames = games.slice(startIndex, endIndex);
                
                // Calculate totals for current result set
                function calculateTotals(gamesList) {
                    let totalAcquisition = 0;
                    let totalCurrent = 0;
                    
                    gamesList.forEach(game => {
                        if (game.purchase_price) {
                            totalAcquisition += game.purchase_price;
                        }
                        if (game.current_price) {
                            totalCurrent += game.current_price;
                        }
                    });
                    
                    return { totalAcquisition, totalCurrent };
                }
                
                const totals = calculateTotals(games);
                
                // Update result count with totals
                const resultCount = document.getElementById('resultCount');
                if (resultCount) {
                    const totalsText = `Total Acquired: ${formatCurrency(totals.totalAcquisition)} | Current Value: ${formatCurrency(totals.totalCurrent)}`;
                    resultCount.innerHTML = `Showing ${startIndex + 1}-${endIndex} of ${games.length} results<br><small class="text-muted">${totalsText}</small>`;
                }

                if (!games || games.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" class="text-center">No games found</td></tr>';
                    return;
                }
                
                // Clear any existing event listeners
                const oldRows = document.querySelectorAll('.game-row');
                oldRows.forEach(row => {
                    row.replaceWith(row.cloneNode(true));
                });
                
                // Render table rows with details rows
                tbody.innerHTML = pageGames.map(game => {
                    const valueChange = !game.is_wanted ? window.formatValueChange(game.current_price, game.purchase_price) : '-';
                    let statusIcon, status;
                    if (game.is_wanted) {
                        statusIcon = '🔖';
                        status = 'Wanted';
                    } else if (game.is_for_sale) {
                        statusIcon = '💰';
                        status = 'For Sale';
                    } else if (game.is_lent) {
                        statusIcon = '📤';
                        status = 'Lent Out';
                    } else {
                        statusIcon = '✓';
                        status = 'Purchased';
                    }
                    
                    return `
                        <tr class="game-row" data-game-id="${game.id}">
                            <td class="status-col d-none d-md-table-cell">${statusIcon}</td>
                            <td class="name-col" title="${game.name}">${game.name}</td>
                            <td class="console-col" title="${game.console}">${game.console}</td>
                            <td class="price-cell d-none d-md-table-cell" title="${formatCurrency(game.current_price)}">${formatCurrency(game.current_price)}</td>
                            <td class="value-change-cell d-none d-md-table-cell">${valueChange}</td>
                            <td class="d-none d-md-table-cell" title="${game.acquisition_date || '-'}">${game.acquisition_date || '-'}</td>
                        </tr>
                        <tr class="details-row">
                            <td colspan="6" class="p-0">
                                <div class="game-details bg-light border-top" data-game-id="${game.id}" style="padding: 1rem; border-left: 4px solid #007bff;">
                                    <!-- Complementary Details (Compact Layout) -->
                                    <div class="row g-2 mb-2">
                                        <div class="col-12">
                                            <div class="d-flex flex-wrap gap-3 align-items-center">
                                                ${!game.is_wanted ? `
                                                    <div class="d-flex align-items-center gap-1">
                                                        <span class="text-muted small">💰</span>
                                                        <span class="fw-bold">${formatCurrency(game.purchase_price)}</span>
                                                        <span class="text-muted small mx-1">→</span>
                                                        <span class="fw-bold text-primary">${formatCurrency(game.current_price)}</span>
                                                    </div>
                                                ` : `
                                                    <div class="d-flex align-items-center gap-1">
                                                        <span class="text-muted small">💰</span>
                                                        <span class="fw-bold text-primary">${formatCurrency(game.current_price)}</span>
                                                    </div>
                                                `}
                                                <div class="d-flex align-items-center gap-1">
                                                    <span class="text-muted small">📦</span>
                                                    <span id="condition-display-${game.id}" class="fw-semibold">${game.condition || 'complete'}</span>
                                                </div>
                                                <div class="d-flex align-items-center gap-1" id="photo-count-${game.id}" style="display: none !important;">
                                                    <a href="#" id="photo-count-link-${game.id}" 
                                                       class="text-decoration-none d-flex align-items-center gap-1"
                                                       onclick="event.preventDefault(); openPhotoGallery(${game.id});"
                                                       title="View photos">
                                                        <span class="text-muted small">📸</span>
                                                        <span class="fw-semibold text-info" id="photo-count-text-${game.id}">0 photos</span>
                                                    </a>
                                                </div>
                                                ${game.is_lent ? `
                                                    <div class="fw-semibold">📤 Lent to ${game.lent_to || 'Unknown'}${game.lent_date ? ` on ${game.lent_date}` : ''}</div>
                                                ` : ''}
                                                ${game.is_for_sale ? `
                                                    <div class="d-flex align-items-center gap-1">
                                                        <span class="text-muted small">💵</span>
                                                        <span class="fw-bold text-success">${formatCurrency(game.asking_price)}</span>
                                                    </div>
                                                ` : ''}
                                                <div class="d-flex align-items-center gap-1">
                                                    <span class="text-muted small">🔄</span>
                                                    <span id="last-update-${game.id}" class="small text-muted">Loading...</span>
                                                </div>
                                            </div>
                                            ${game.is_for_sale && game.sale_notes ? `
                                                <div class="mt-1 small text-muted">📝 ${game.sale_notes}</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <!-- Expandable Metadata Section -->
                                    <div class="mb-2">
                                        <button class="btn btn-sm btn-link p-0 text-decoration-none metadata-toggle-btn" 
                                                data-game-id="${game.id}"
                                                style="font-size: 0.8rem; color: #6c757d;">
                                            <span class="toggle-icon">▶</span> All Game Metadata
                                        </button>
                                        <div class="metadata-details mt-2" data-game-id="${game.id}" style="display: none;">
                                            <div class="table-responsive">
                                                <table class="table table-sm table-borderless mb-0" style="font-size: 0.8rem;">
                                                    <tbody>
                                                        <tr>
                                                            <td class="text-muted" style="width: 40%;">Name:</td>
                                                            <td class="fw-semibold">${game.name}</td>
                                                        </tr>
                                                        <tr>
                                                            <td class="text-muted">Console:</td>
                                                            <td class="fw-semibold">${game.console}</td>
                                                        </tr>
                                                        <tr>
                                                            <td class="text-muted">Condition:</td>
                                                            <td>${game.condition || 'complete'}</td>
                                                        </tr>
                                                        ${!game.is_wanted ? `
                                                            <tr>
                                                                <td class="text-muted">Purchase Price:</td>
                                                                <td class="fw-bold">${formatCurrency(game.purchase_price)}</td>
                                                            </tr>
                                                            <tr>
                                                                <td class="text-muted">Current Price:</td>
                                                                <td class="fw-bold text-primary">${formatCurrency(game.current_price)}</td>
                                                            </tr>
                                                            <tr>
                                                                <td class="text-muted">Value Change:</td>
                                                                <td>${valueChange}</td>
                                                            </tr>
                                                            <tr>
                                                                <td class="text-muted">Acquisition Date:</td>
                                                                <td>${game.acquisition_date || '-'}</td>
                                                            </tr>
                                                        ` : `
                                                            <tr>
                                                                <td class="text-muted">Current Price:</td>
                                                                <td class="fw-bold text-primary">${formatCurrency(game.current_price)}</td>
                                                            </tr>
                                                        `}
                                                        ${game.is_lent ? `
                                                            <tr>
                                                                <td class="text-muted">Lent To:</td>
                                                                <td class="fw-semibold">${game.lent_to || 'Unknown'}</td>
                                                            </tr>
                                                            <tr>
                                                                <td class="text-muted">Lent Date:</td>
                                                                <td>${game.lent_date || '-'}</td>
                                                            </tr>
                                                        ` : ''}
                                                        ${game.is_for_sale ? `
                                                            <tr>
                                                                <td class="text-muted">Asking Price:</td>
                                                                <td class="fw-bold text-success">${formatCurrency(game.asking_price)}</td>
                                                            </tr>
                                                            <tr>
                                                                <td class="text-muted">Sale Date Marked:</td>
                                                                <td>${game.sale_date_marked || '-'}</td>
                                                            </tr>
                                                            ${game.sale_notes ? `
                                                                <tr>
                                                                    <td class="text-muted">Sale Notes:</td>
                                                                    <td>${game.sale_notes}</td>
                                                                </tr>
                                                            ` : ''}
                                                        ` : ''}
                                                        <tr id="photos-meta-row-${game.id}" style="display: none;">
                                                            <td class="text-muted">Photos:</td>
                                                            <td id="photos-meta-${game.id}">Loading...</td>
                                                        </tr>
                                                        <tr>
                                                            <td class="text-muted">Last Price Update:</td>
                                                            <td><span id="last-update-meta-${game.id}" class="small">Loading...</span></td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Quick Actions Section -->
                                    <div class="mb-2 pb-2 border-bottom">
                                        <small class="text-muted d-block mb-1">⚡ Quick Actions</small>
                                        <div class="d-flex flex-wrap gap-1">
                                            <button class="btn btn-sm btn-outline-secondary edit-details-btn" 
                                                    data-game-id="${game.id}" 
                                                    data-game-name="${game.name}"
                                                    data-game-console="${game.console}"
                                                    data-current-condition="${game.condition || 'complete'}"
                                                    data-is-wanted="${game.is_wanted}"
                                                    style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                ✏️ Edit Details
                                            </button>
                                            <button class="btn btn-sm btn-outline-primary update-price-btn" 
                                                    data-game-id="${game.id}" 
                                                    style="font-size: 0.7rem; padding: 0.2rem 0.4rem;"
                                                    title="Update Price">
                                                🔄 Update Price
                                            </button>
                                            <button class="btn btn-sm btn-outline-info add-photos-btn" 
                                                    data-game-id="${game.id}" 
                                                    data-game-name="${game.name}"
                                                    data-game-console="${game.console}"
                                                    style="font-size: 0.7rem; padding: 0.2rem 0.4rem;"
                                                    title="Add Photos">
                                                📸 Add Photos
                                            </button>
                                                ${game.is_wanted ? `
                                                    <button class="btn btn-sm btn-outline-success purchase-wishlist-btn" 
                                                            data-game-id="${game.id}" 
                                                            data-game-name="${game.name}"
                                                            data-game-console="${game.console}"
                                                            style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                        📦 Purchase
                                                    </button>
                                                    <button class="btn btn-sm btn-outline-danger remove-wishlist-btn" 
                                                            data-game-id="${game.id}" 
                                                            data-game-name="${game.name}"
                                                            data-game-console="${game.console}"
                                                            style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                        🗑️ Remove
                                                    </button>
                                                ` : `
                                                    ${game.is_lent ? `
                                                        <button class="btn btn-sm btn-outline-success unmark-lent-btn" 
                                                                data-game-id="${game.id}" 
                                                                data-game-name="${game.name}"
                                                                data-game-console="${game.console}"
                                                                data-lent-to="${game.lent_to}"
                                                                style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                            🔄 Return
                                                        </button>
                                                    ` : `
                                                        ${game.is_for_sale ? `
                                                            <button class="btn btn-sm btn-outline-warning unmark-for-sale-btn" 
                                                                    data-game-id="${game.id}" 
                                                                    data-game-name="${game.name}"
                                                                    data-game-console="${game.console}"
                                                                    style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                                🚫 Unmark Sale
                                                            </button>
                                                        ` : `
                                                            <button class="btn btn-sm btn-outline-success mark-for-sale-btn" 
                                                                    data-game-id="${game.id}" 
                                                                    data-game-name="${game.name}"
                                                                    data-game-console="${game.console}"
                                                                    style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                                💰 Mark Sale
                                                            </button>
                                                        `}
                                                        <button class="btn btn-sm btn-outline-primary mark-lent-btn" 
                                                                data-game-id="${game.id}" 
                                                                data-game-name="${game.name}"
                                                                data-game-console="${game.console}"
                                                                style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                            📤 Mark Lent
                                                        </button>
                                                    `}
                                                    <button class="btn btn-sm btn-outline-danger remove-from-collection-btn" 
                                                            data-game-id="${game.id}" 
                                                            data-purchased-game-id="${game.purchased_game_id}"
                                                            data-game-name="${game.name}"
                                                            data-game-console="${game.console}"
                                                            style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">
                                                        🗑️ Remove
                                                    </button>
                                                `}
                                        </div>
                                    </div>
                                    
                                    <!-- Price History Chart -->
                                    <div class="pt-2">
                                        <small class="text-muted d-block mb-2">📈 Price History</small>
                                        <div id="sparkline-${game.id}" class="sparkline-container"></div>
                                    </div>
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
                
                // Add click handlers
                document.querySelectorAll('.game-row').forEach(row => {
                    row.addEventListener('click', function(e) {
                        const gameId = this.dataset.gameId;
                        const detailsDiv = document.querySelector(`.game-details[data-game-id="${gameId}"]`);
                        
                        if (!detailsDiv) return;
                        
                        const wasVisible = detailsDiv.classList.contains('show');
                        
                        // Hide all details and remove selected state
                        document.querySelectorAll('.game-details').forEach(div => div.classList.remove('show'));
                        document.querySelectorAll('.game-row').forEach(r => r.classList.remove('selected'));
                        
                        // Show this one if it wasn't visible
                        if (!wasVisible) {
                            detailsDiv.classList.add('show');
                            this.classList.add('selected');
                            
                            // Fetch and show price history
                            fetchPriceHistory(gameId);
                            
                            // Fetch last price update for metadata section
                            fetchLastPriceUpdateForMetadata(gameId);
                            
                            // Load photo count for this game
                            loadPhotoCount(gameId);
                        }
                    });
                });
                
                // Add metadata toggle handlers
                document.querySelectorAll('.metadata-toggle-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const gameId = this.dataset.gameId;
                        const metadataDetails = document.querySelector(`.metadata-details[data-game-id="${gameId}"]`);
                        const toggleIcon = this.querySelector('.toggle-icon');
                        
                        if (metadataDetails.style.display === 'none') {
                            metadataDetails.style.display = 'block';
                            toggleIcon.textContent = '▼';
                        } else {
                            metadataDetails.style.display = 'none';
                            toggleIcon.textContent = '▶';
                        }
                    });
                });
                
                // Update pagination UI
                const pagination = document.getElementById('collectionPagination');
                if (pagination) {
                    pagination.innerHTML = generatePaginationHTML(page, totalPages);
                    
                    // Add click handlers for pagination
                    pagination.querySelectorAll('.page-link').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            const newPage = parseInt(e.target.dataset.page);
                            if (!isNaN(newPage)) {
                                renderGames(games, true, newPage);
                            }
                        });
                    });
                }
            }; // End of window.renderGames function
            
            // Sort games by a specific key
            function sortGames(games, sortKey, sortOrder) {
                console.log(`Sorting games by ${sortKey} in ${sortOrder} order`);
                return [...games].sort((a, b) => {
                    let aVal, bVal;
                    
                    if (sortKey === 'is_wanted') {
                        aVal = a[sortKey] ? 1 : 0;
                        bVal = b[sortKey] ? 1 : 0;
                    } else if (sortKey === 'current_price') {
                        aVal = parseFloat(a[sortKey]) || 0;
                        bVal = parseFloat(b[sortKey]) || 0;
                    } else if (sortKey === 'value_change') {
                        // Calculate value change percentage for sorting
                        const aChange = !a.is_wanted && a.current_price && a.purchase_price ? 
                            ((a.current_price - a.purchase_price) / a.purchase_price) * 100 : -Infinity;
                        const bChange = !b.is_wanted && b.current_price && b.purchase_price ? 
                            ((b.current_price - b.purchase_price) / b.purchase_price) * 100 : -Infinity;
                        
                        aVal = aChange;
                        bVal = bChange;
                    } else if (sortKey === 'acquisition_date') {
                        aVal = a[sortKey] ? new Date(a[sortKey]).getTime() : 0;
                        bVal = b[sortKey] ? new Date(b[sortKey]).getTime() : 0;
                    } else {
                        aVal = a[sortKey];
                        bVal = b[sortKey];
                    }
                    
                    // Handle null values for non-value_change fields
                    if (sortKey !== 'value_change') {
                        if (aVal === null || aVal === undefined) aVal = sortOrder === 'asc' ? '\uffff' : '';
                        if (bVal === null || bVal === undefined) bVal = sortOrder === 'asc' ? '\uffff' : '';
                    }
                    
                    // Compare the values
                    if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;
                    if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Setup sorting functionality
            function setupSorting(tableId, defaultSort = 'name', defaultOrder = 'asc') {
                console.log('Setting up sorting');
                const table = document.getElementById(tableId);
                if (!table) {
                    console.error('Table not found:', tableId);
                    return;
                }
                
                let currentSort = defaultSort;
                let currentOrder = defaultOrder;
                
                const headers = table.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    const sortKey = header.dataset.sort;
                    console.log('Setting up sort header:', sortKey);
                    
                    if (sortKey === defaultSort) {
                        header.classList.add(`sort-${defaultOrder}`);
                    }
                    
                    header.addEventListener('click', () => {
                        console.log('Sort header clicked:', sortKey);
                        // Update sort direction
                        if (sortKey === currentSort) {
                            currentOrder = currentOrder === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort = sortKey;
                            currentOrder = 'asc';
                        }
                        
                        console.log('New sort:', currentSort, currentOrder);
                        
                        // Update header classes
                        headers.forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                        });
                        header.classList.add(`sort-${currentOrder}`);
                        
                        // Sort the games
                        console.log('Sorting games, count:', filteredGames.length);
                        const sortedGames = sortGames(filteredGames, currentSort, currentOrder);
                        renderGames(sortedGames, true, 1); // Reset to first page when sorting
                    });
                });
                
                return { currentSort, currentOrder };
            }

            // Setup table search functionality
            function setupTableSearch() {
                console.log('Setting up table search');
                const searchInput = document.getElementById('searchInput');
                if (!searchInput) {
                    console.error('Search input not found!');
                    return;
                }
                
                let debounceTimeout;
                searchInput.addEventListener('input', (e) => {
                    console.log('Search input changed:', e.target.value);
                    clearTimeout(debounceTimeout);
                    debounceTimeout = setTimeout(() => {
                        const searchTerm = e.target.value;
                        console.log('Filtering with term:', searchTerm);
                        const filtered = window.filterGames(window.allGames, searchTerm);
                        console.log('Found filtered games:', filtered.length);
                        renderGames(filtered, false, 1); // Reset to first page when filtering
                        
                        // Update URL parameters for bookmarkable searches
                        updateUrlParameters();
                    }, 300);
                });
            }

            // Add function to populate console filter
            function populateConsoleFilter(games) {
                const consoles = [...new Set(games.map(game => game.console))].sort();
                const consoleFilter = document.getElementById('consoleFilter');
                
                // Clear existing checkboxes except "All Consoles"
                const allConsoleCheckbox = document.getElementById('consoleAll');
                consoleFilter.innerHTML = '';
                consoleFilter.appendChild(allConsoleCheckbox.parentElement);
                
                // Add checkbox for each console
                consoles.forEach((consoleName, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'form-check';
                    
                    const checkbox = document.createElement('input');
                    checkbox.className = 'form-check-input';
                    checkbox.type = 'checkbox';
                    checkbox.id = `console_${index}`;
                    checkbox.value = consoleName.toLowerCase();
                    
                    const label = document.createElement('label');
                    label.className = 'form-check-label';
                    label.setAttribute('for', `console_${index}`);
                    label.textContent = consoleName;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    consoleFilter.appendChild(checkboxDiv);
                    
                    // Add event listener for individual console checkboxes
                    checkbox.addEventListener('change', handleConsoleCheckboxChange);
                });
                
                // Add event listener for "All Consoles" checkbox
                allConsoleCheckbox.addEventListener('change', handleAllConsolesCheckbox);
                
                // Setup dropdown toggle functionality
                setupConsoleDropdown();
            }
            
            // Setup console dropdown functionality
            function setupConsoleDropdown() {
                const dropdownToggle = document.getElementById('consoleDropdownToggle');
                const dropdownContainer = document.getElementById('consoleFilter');
                
                // Toggle dropdown visibility
                dropdownToggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    const isOpen = dropdownContainer.style.display === 'block';
                    dropdownContainer.style.display = isOpen ? 'none' : 'block';
                    dropdownToggle.setAttribute('aria-expanded', !isOpen);
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', function(e) {
                    if (!dropdownToggle.contains(e.target) && !dropdownContainer.contains(e.target)) {
                        dropdownContainer.style.display = 'none';
                        dropdownToggle.setAttribute('aria-expanded', 'false');
                    }
                });
            }
            
            // Update dropdown display text based on selections
            function updateConsoleDropdownText() {
                const allCheckbox = document.getElementById('consoleAll');
                const consoleCheckboxes = document.querySelectorAll('#consoleFilter input[type="checkbox"]:not(#consoleAll)');
                const dropdownText = document.querySelector('.console-dropdown-text');
                
                if (allCheckbox.checked) {
                    dropdownText.textContent = 'All Consoles';
                } else {
                    const checkedConsoles = Array.from(consoleCheckboxes)
                        .filter(checkbox => checkbox.checked)
                        .map(checkbox => checkbox.nextElementSibling.textContent);
                    
                    if (checkedConsoles.length === 0) {
                        dropdownText.textContent = 'All Consoles';
                    } else if (checkedConsoles.length === 1) {
                        dropdownText.textContent = checkedConsoles[0];
                    } else {
                        dropdownText.textContent = `${checkedConsoles.length} consoles selected`;
                    }
                }
            }
            
            // Handle "All Consoles" checkbox changes
            function handleAllConsolesCheckbox() {
                const allCheckbox = document.getElementById('consoleAll');
                const consoleCheckboxes = document.querySelectorAll('#consoleFilter input[type="checkbox"]:not(#consoleAll)');
                
                if (allCheckbox.checked) {
                    // Uncheck all individual console checkboxes
                    consoleCheckboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                }
                
                updateConsoleDropdownText();
                applyFilters();
            }
            
            // Handle individual console checkbox changes
            function handleConsoleCheckboxChange() {
                const allCheckbox = document.getElementById('consoleAll');
                const consoleCheckboxes = document.querySelectorAll('#consoleFilter input[type="checkbox"]:not(#consoleAll)');
                const anyChecked = Array.from(consoleCheckboxes).some(checkbox => checkbox.checked);
                
                if (anyChecked) {
                    // If any individual console is checked, uncheck "All Consoles"
                    allCheckbox.checked = false;
                } else {
                    // If no individual consoles are checked, check "All Consoles"
                    allCheckbox.checked = true;
                }
                
                updateConsoleDropdownText();
                applyFilters();
            }

            // Initialize
            console.log('Starting initialization...');
            await loadAllGames(); // Load all games first
            setupTableSearch();
            
            // Populate console filter after loading games
            populateConsoleFilter(window.allGames);
            
            // Setup advanced search toggle
            const advancedSearchBtn = document.getElementById('advancedSearchBtn');
            const advancedSearchPanel = document.getElementById('advancedSearch');
            
            advancedSearchBtn.addEventListener('click', () => {
                const isHidden = advancedSearchPanel.style.display === 'none';
                advancedSearchPanel.style.display = isHidden ? 'block' : 'none';
                advancedSearchBtn.setAttribute('aria-expanded', !isHidden);
            });
            
            // Add event listeners for advanced filters
            const applyFilters = () => {
                const searchTerm = document.getElementById('searchInput').value;
                const filtered = window.filterGames(window.allGames, searchTerm);
                
                // Calculate totals for filtered results
                let totalAcquisition = 0;
                let totalCurrent = 0;
                
                filtered.forEach(game => {
                    if (game.purchase_price) {
                        totalAcquisition += game.purchase_price;
                    }
                    if (game.current_price) {
                        totalCurrent += game.current_price;
                    }
                });
                
                const resultCount = document.getElementById('resultCount');
                if (resultCount) {
                    const totalsText = `Total Acquired: ${formatCurrency(totalAcquisition)} | Current Value: ${formatCurrency(totalCurrent)}`;
                    resultCount.innerHTML = `${filtered.length} games found<br><small class="text-muted">${totalsText}</small>`;
                }
                renderGames(filtered, false, 1);
                
                // Update URL parameters for bookmarkable searches
                updateUrlParameters();
            };
            
            document.getElementById('statusFilter').addEventListener('change', applyFilters);
            document.getElementById('conditionFilter').addEventListener('change', applyFilters);
            
            // URL parameter functions for bookmarkable/shareable searches
            function readUrlParameters() {
                const urlParams = new URLSearchParams(window.location.search);
                
                // Read search term
                const searchTerm = urlParams.get('search');
                if (searchTerm) {
                    document.getElementById('searchInput').value = searchTerm;
                }
                
                // Read status filter
                const status = urlParams.get('status');
                if (status) {
                    document.getElementById('statusFilter').value = status;
                }
                
                // Read condition filter
                const condition = urlParams.get('condition');
                if (condition) {
                    document.getElementById('conditionFilter').value = condition;
                }
                
                // Read console filters
                const consoles = urlParams.get('consoles');
                if (consoles) {
                    const selectedConsoles = consoles.split(',');
                    // Uncheck "All Consoles" first
                    document.getElementById('consoleAll').checked = false;
                    // Check selected consoles
                    selectedConsoles.forEach(console => {
                        const checkbox = document.querySelector(`#consoleFilter input[value="${console.toLowerCase()}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    });
                    updateConsoleDropdownText();
                }
            }
            
            function updateUrlParameters() {
                const urlParams = new URLSearchParams();
                
                // Add search term
                const searchTerm = document.getElementById('searchInput').value.trim();
                if (searchTerm) {
                    urlParams.set('search', searchTerm);
                }
                
                // Add status filter
                const status = document.getElementById('statusFilter').value;
                if (status) {
                    urlParams.set('status', status);
                }
                
                // Add condition filter
                const condition = document.getElementById('conditionFilter').value;
                if (condition) {
                    urlParams.set('condition', condition);
                }
                
                // Add console filters
                const allConsolesChecked = document.getElementById('consoleAll').checked;
                if (!allConsolesChecked) {
                    const selectedConsoles = [];
                    const consoleCheckboxes = document.querySelectorAll('#consoleFilter input[type="checkbox"]:not(#consoleAll)');
                    consoleCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedConsoles.push(checkbox.value);
                        }
                    });
                    if (selectedConsoles.length > 0) {
                        urlParams.set('consoles', selectedConsoles.join(','));
                    }
                }
                
                // Update URL without page reload
                const newUrl = urlParams.toString() ? `${window.location.pathname}?${urlParams.toString()}` : window.location.pathname;
                window.history.replaceState(null, '', newUrl);
            }
            
            // Read URL parameters on page load
            readUrlParameters();
            
            // Apply any persisted search filters on page load
            applyFilters();
            
            const { currentSort, currentOrder } = setupSorting('collectionTable', 'acquisition_date', 'desc');
            // Apply initial sort
            const initialSortedGames = sortGames(filteredGames, currentSort, currentOrder);
            renderGames(initialSortedGames, true, 1);
            
            // Setup wishlist functionality
            setupWishlistDialog();
            
            console.log('Initialization complete');
        });
        
        // Wishlist functionality
        function setupWishlistDialog() {
            const addToWishlistBtn = document.getElementById('addToWishlistBtn');
            const wishlistModal = new bootstrap.Modal(document.getElementById('wishlistModal'));
            const submitGameBtn = document.getElementById('submitGameBtn');
            const gameForm = document.getElementById('gameForm');
            const urlInput = document.getElementById('pricechartingUrl');
            const conditionSelect = document.getElementById('gameCondition');
            const errorDiv = document.getElementById('formError');
            const successDiv = document.getElementById('formSuccess');
            
            const wishlistTab = document.getElementById('wishlist-tab');
            const purchasedTab = document.getElementById('purchased-tab');
            const wishlistTabPane = document.getElementById('wishlist-tab-pane');
            const purchasedTabPane = document.getElementById('purchased-tab-pane');
            
            let currentMode = 'wishlist'; // Default mode
            
            // Toggle purchased fields based on tab selection
            wishlistTab.addEventListener('click', () => {
                currentMode = 'wishlist';
                submitGameBtn.textContent = 'Add to Wishlist';
            });
            
            purchasedTab.addEventListener('click', () => {
                currentMode = 'purchased';
                submitGameBtn.textContent = 'Add Purchased Game';
            });
            
            // Show the modal when the add button is clicked
            addToWishlistBtn.addEventListener('click', () => {
                resetGameForm();
                wishlistModal.show();
            });
            
            // Handle form submission
            submitGameBtn.addEventListener('click', async () => {
                // Validate form
                if (!urlInput.value) {
                    showError('Please enter a valid pricecharting.com URL');
                    return;
                }
                
                // Validate URL format
                if (!urlInput.value.startsWith('https://www.pricecharting.com/game/')) {
                    showError('URL must be from pricecharting.com and follow the format https://www.pricecharting.com/game/{console}/{game-name}');
                    return;
                }
                
                // Determine if adding to wishlist or as purchased
                const isWishlist = currentMode === 'wishlist';
                
                // Additional validation for purchased games
                if (!isWishlist) {
                    const purchaseDate = document.getElementById('purchaseDate').value;
                    const purchasePrice = document.getElementById('purchasePrice').value;
                    
                    if (!purchaseDate) {
                        showError('Please enter a purchase date');
                        return;
                    }
                    
                    if (!purchasePrice) {
                        showError('Please enter a purchase price');
                        return;
                    }
                }
                
                // Disable button to prevent multiple submissions
                submitGameBtn.disabled = true;
                submitGameBtn.textContent = isWishlist ? 'Adding to Wishlist...' : 'Adding Purchased Game...';
                
                try {
                    // Prepare data to send
                    let requestData = {
                        url: urlInput.value,
                        condition: conditionSelect.value
                    };
                    
                    // Add purchase details if needed
                    if (!isWishlist) {
                        requestData.purchase_date = document.getElementById('purchaseDate').value;
                        requestData.purchase_source = document.getElementById('purchaseSource').value || null;
                        requestData.purchase_price = parseFloat(document.getElementById('purchasePrice').value);
                    }
                    
                    // Use optimistic update functions
                    let result;
                    if (isWishlist) {
                        result = await window.addToWishlistOptimistic(requestData);
                    } else {
                        result = await window.addToCollectionOptimistic(requestData);
                    }
                    
                    // Reset form after successful addition
                    // Clear the form for next entry but keep modal open
                    urlInput.value = '';
                    conditionSelect.value = 'CIB';
                    
                    // Clear purchase fields if in purchased mode
                    if (!isWishlist) {
                        document.getElementById('purchaseDate').value = new Date().toISOString().split('T')[0];
                        document.getElementById('purchaseSource').value = '';
                        document.getElementById('purchasePrice').value = '';
                    }
                    
                    // Keep success message visible for a bit longer, then hide
                    setTimeout(() => {
                        const successDiv = document.getElementById('wishlistSuccessMessage');
                        if (successDiv) {
                            successDiv.classList.add('d-none');
                        }
                    }, 3000);
                    
                } catch (error) {
                    console.error(`Error adding game ${isWishlist ? 'to wishlist' : 'to collection'}:`, error);
                    // Show error message
                    showError(error.message || 'An error occurred');
                    
                } finally {
                    // Re-enable button
                    submitGameBtn.disabled = false;
                    submitGameBtn.textContent = isWishlist ? 'Add to Wishlist' : 'Add Purchased Game';
                }
            });
            
            // Helper functions
            function resetGameForm() {
                gameForm.reset();
                errorDiv.classList.add('d-none');
                successDiv.classList.add('d-none');
                submitGameBtn.disabled = false;
                
                // Set current date for the purchase date
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('purchaseDate').value = today;
                
                // Reset to default tab (wishlist)
                currentMode = 'wishlist';
                submitGameBtn.textContent = 'Add to Wishlist';
                
                // Activate the wishlist tab
                const tabTrigger = new bootstrap.Tab(wishlistTab);
                tabTrigger.show();
            }
            
            function showError(message) {
                errorDiv.textContent = message;
                errorDiv.classList.remove('d-none');
                successDiv.classList.add('d-none');
            }
            
            function showSuccess(message) {
                successDiv.textContent = message;
                successDiv.classList.remove('d-none');
                errorDiv.classList.add('d-none');
            }
        }
        
        // Function to fetch price history and render sparkline
        async function fetchPriceHistory(gameId) {
            try {
                const sparklineContainer = document.getElementById(`sparkline-${gameId}`);
                if (!sparklineContainer) return;
                
                // Show loading state
                sparklineContainer.innerHTML = '<div class="text-center"><small>Loading price history...</small></div>';
                
                // Fetch price history data from API
                const response = await fetch(`/api/game/${gameId}/price_history`);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    sparklineContainer.innerHTML = `<div class="text-center text-muted"><small>${errorData.error || 'Failed to load price history'}</small></div>`;
                    return;
                }
                
                const priceHistory = await response.json();
                
                if (!priceHistory || priceHistory.length === 0) {
                    sparklineContainer.innerHTML = '<div class="text-center text-muted"><small>No price history available</small></div>';
                    return;
                }
                
                // Create a chart container with proper height
                sparklineContainer.innerHTML = '<div class="sparkline-chart"></div>';
                const chartElement = sparklineContainer.querySelector('.sparkline-chart');
                
                // Debug
                console.log('Price history data:', priceHistory);
                
                // Ensure data is sorted by date (ascending)
                priceHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // Prepare data for sparkline
                const seriesData = priceHistory.map(item => {
                    // Ensure we have valid numbers
                    const price = item.price !== null && item.price !== undefined ? parseFloat(item.price) : null;
                    return isNaN(price) ? null : price;
                }).filter(price => price !== null);
                
                // Debug
                console.log('Series data:', seriesData);
                
                if (seriesData.length === 0) {
                    sparklineContainer.innerHTML = '<div class="text-center text-muted"><small>No valid price data available</small></div>';
                    return;
                }
                
                const categories = priceHistory.map(item => new Date(item.date).toLocaleDateString());
                
                // Get first and last values for y-axis labels
                const firstValue = seriesData[0];
                const lastValue = seriesData[seriesData.length - 1];
                
                // Create sparkline chart
                const options = {
                    series: [{
                        name: 'Value',
                        data: seriesData
                    }],
                    chart: {
                        type: 'area',
                        height: 60,
                        sparkline: {
                            enabled: true
                        },
                        animations: {
                            enabled: true,
                            easing: 'easeinout',
                            speed: 800
                        },
                        toolbar: {
                            show: false
                        }
                    },
                    stroke: {
                        curve: 'smooth',
                        width: 2
                    },
                    fill: {
                        opacity: 0.3
                    },
                    tooltip: {
                        enabled: true,
                        fixed: {
                            enabled: false
                        },
                        x: {
                            show: true,
                            formatter: function(value, { series, seriesIndex, dataPointIndex }) {
                                return categories[dataPointIndex];
                            }
                        },
                        y: {
                            formatter: function (value) {
                                return window.formatCurrency(value);
                            },
                            title: {
                                formatter: () => 'Value:'
                            }
                        }
                    },
                    colors: ['#4CAF50'],
                    grid: {
                        show: false,
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        labels: {
                            show: false
                        },
                        axisTicks: {
                            show: false
                        },
                        axisBorder: {
                            show: false
                        }
                    },
                    yaxis: {
                        labels: {
                            show: false
                        },
                        min: Math.floor(Math.min(...seriesData) * 0.95),
                        max: Math.ceil(Math.max(...seriesData) * 1.05)
                    }
                };
                
                // Only add annotations if we have valid data
                if (firstValue !== undefined && lastValue !== undefined) {
                    // Remove annotations - we don't want to show the labels
                }
                
                try {
                    const chart = new ApexCharts(chartElement, options);
                    chart.render();
                } catch (chartError) {
                    console.error('Error rendering chart:', chartError);
                    sparklineContainer.innerHTML = '<div class="text-center text-muted"><small>Error rendering price chart</small></div>';
                }
            } catch (error) {
                console.error('Error fetching price history:', error);
                const sparklineContainer = document.getElementById(`sparkline-${gameId}`);
                if (sparklineContainer) {
                    sparklineContainer.innerHTML = `<div class="text-center text-muted"><small>Error: ${error.message}</small></div>`;
                }
            }
        }

        // Price update functionality
        async function updateGamePrice(gameId) {
            const button = document.querySelector(`.update-price-btn[data-game-id="${gameId}"]`);
            if (!button) return;
            
            const originalText = button.textContent;
            button.textContent = 'Retrieving...';
            button.disabled = true;
            
            try {
                const response = await fetch(`/api/game/${gameId}/update_price`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    button.textContent = 'Updated!';
                    button.classList.remove('btn-outline-primary');
                    button.classList.add('btn-success');
                    
                    // Fetch the updated game data and update UI immediately
                    try {
                        const gameResponse = await fetch(`/api/game/${gameId}`);
                        
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            const updatedGame = gameData.game;
                            
                            // Update the game in window.allGames
                            const gameIndex = window.allGames.findIndex(g => g.id == gameId);
                            if (gameIndex !== -1) {
                                window.allGames[gameIndex] = updatedGame;
                            }
                            
                            // Update game state manager if it exists
                            if (window.gameStateManager) {
                                window.gameStateManager.updateGame(updatedGame);
                            }
                            
                            // Update table row price immediately
                            const tableRow = document.querySelector(`tr.game-row[data-game-id="${gameId}"]`);
                            if (tableRow) {
                                // Update current price cell
                                const priceCell = tableRow.querySelector('.price-cell');
                                if (priceCell) {
                                    const formattedPrice = formatCurrency(updatedGame.current_price);
                                    priceCell.textContent = formattedPrice;
                                    priceCell.title = formattedPrice;
                                }
                                
                                // Update value change cell
                                const valueChangeCell = tableRow.querySelector('.value-change-cell');
                                if (valueChangeCell) {
                                    if (!updatedGame.is_wanted) {
                                        const valueChange = window.formatValueChange(updatedGame.current_price, updatedGame.purchase_price);
                                        valueChangeCell.innerHTML = valueChange;
                                    } else {
                                        valueChangeCell.innerHTML = '-';
                                    }
                                }
                            }
                            
                            // Update expanded card price if it's currently open
                            const gameDetails = document.querySelector(`div.game-details[data-game-id="${gameId}"]`);
                            if (gameDetails) {
                                // Update current price in summary line (more specific targeting)
                                const summaryContainer = gameDetails.querySelector('.d-flex.flex-wrap.gap-3.align-items-center');
                                if (summaryContainer) {
                                    // Find the current price span (it's the second price shown, or only price for wanted games)
                                    const priceSpans = summaryContainer.querySelectorAll('.fw-bold');
                                    priceSpans.forEach(span => {
                                        // Update the current price span (text-primary class or second price)
                                        if (span.classList.contains('text-primary') || 
                                            (priceSpans.length > 1 && span === priceSpans[1])) {
                                            span.textContent = formatCurrency(updatedGame.current_price);
                                        }
                                    });
                                }
                                
                                // Update current price and change in the old expanded card structure (if any)
                                const ddElements = gameDetails.querySelectorAll('dd');
                                ddElements.forEach((dd) => {
                                    const dt = dd.previousElementSibling;
                                    if (dt) {
                                        const labelText = dt.textContent.trim();
                                        if (labelText === 'Current Price' || labelText === 'Current') {
                                            dd.textContent = formatCurrency(updatedGame.current_price);
                                        } else if (labelText === 'Change') {
                                            if (!updatedGame.is_wanted) {
                                                const valueChange = window.formatValueChange(updatedGame.current_price, updatedGame.purchase_price);
                                                dd.innerHTML = valueChange;
                                            } else {
                                                dd.innerHTML = '-';
                                            }
                                        }
                                    }
                                });
                                
                                // Update metadata table current price and value change
                                const metadataTable = gameDetails.querySelector('.metadata-details table tbody');
                                if (metadataTable) {
                                    const rows = metadataTable.querySelectorAll('tr');
                                    rows.forEach(row => {
                                        const label = row.querySelector('td:first-child');
                                        const value = row.querySelector('td:last-child');
                                        if (label && value) {
                                            const labelText = label.textContent.trim();
                                            if (labelText === 'Current Price:') {
                                                value.innerHTML = `<span class="fw-bold text-primary">${formatCurrency(updatedGame.current_price)}</span>`;
                                            } else if (labelText === 'Value Change:') {
                                                if (!updatedGame.is_wanted) {
                                                    const valueChange = window.formatValueChange(updatedGame.current_price, updatedGame.purchase_price);
                                                    value.innerHTML = valueChange;
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Update last price update timestamp in expanded card
                                fetchLastPriceUpdate(gameId);
                                fetchLastPriceUpdateForMetadata(gameId);
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching updated game data:', error);
                    }
                    
                    // Reset button after 2 seconds
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                        button.classList.remove('btn-success');
                        button.classList.add('btn-outline-primary');
                    }, 2000);
                    
                } else {
                    button.textContent = 'Failed';
                    button.classList.remove('btn-outline-primary');
                    button.classList.add('btn-danger');
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                        button.classList.remove('btn-danger');
                        button.classList.add('btn-outline-primary');
                    }, 2000);
                }
                
            } catch (error) {
                console.error('Error updating price:', error);
                button.textContent = 'Error';
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-danger');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                    button.classList.remove('btn-danger');
                    button.classList.add('btn-outline-primary');
                }, 2000);
            }
        }
        
        async function fetchLastPriceUpdate(gameId) {
            try {
                const response = await fetch(`/api/game/${gameId}/last_price_update`);
                const result = await response.json();
                
                const updateElement = document.getElementById(`last-update-${gameId}`);
                if (updateElement) {
                    if (result.last_update) {
                        const date = new Date(result.last_update);
                        updateElement.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    } else {
                        updateElement.textContent = 'Never';
                    }
                }
            } catch (error) {
                console.error('Error fetching last price update:', error);
                const updateElement = document.getElementById(`last-update-${gameId}`);
                if (updateElement) {
                    updateElement.textContent = 'Error';
                }
            }
        }
        
        async function fetchLastPriceUpdateForMetadata(gameId) {
            try {
                const response = await fetch(`/api/game/${gameId}/last_price_update`);
                const result = await response.json();
                
                const updateElement = document.getElementById(`last-update-meta-${gameId}`);
                if (updateElement) {
                    if (result.last_update) {
                        const date = new Date(result.last_update);
                        updateElement.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    } else {
                        updateElement.textContent = 'Never';
                    }
                }
            } catch (error) {
                console.error('Error fetching metadata price update:', error);
                const updateElement = document.getElementById(`last-update-meta-${gameId}`);
                if (updateElement) {
                    updateElement.textContent = 'Error loading';
                }
            }
        }
        
        // Set up event delegation for price update buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('update-price-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const gameId = e.target.dataset.gameId;
                if (gameId) {
                    updateGamePrice(gameId);
                }
            }
            
            // Handle purchase button clicks
            if (e.target.classList.contains('purchase-wishlist-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                
                if (gameId && gameName && gameConsole) {
                    openPurchaseModal(gameId, gameName, gameConsole);
                }
            }
            
            // Handle remove from wishlist button clicks
            if (e.target.classList.contains('remove-wishlist-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                
                if (gameId && gameName && gameConsole) {
                    removeFromWishlist(gameId, gameName, gameConsole, e.target);
                }
            }
        });
        
        // Purchase modal functionality
        function openPurchaseModal(gameId, gameName, gameConsole) {
            // Clear any previous error/success messages
            document.getElementById('purchaseError').classList.add('d-none');
            document.getElementById('purchaseSuccess').classList.add('d-none');
            
            // Set game info in modal
            document.getElementById('purchaseGameName').textContent = gameName;
            document.getElementById('purchaseGameConsole').textContent = gameConsole;
            
            // Set today's date as default
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('purchaseDateInput').value = today;
            
            // Clear other form fields
            document.getElementById('purchaseSourceInput').value = '';
            document.getElementById('purchasePriceInput').value = '';
            
            // Store game ID on the modal for later use
            const purchaseModal = document.getElementById('purchaseModal');
            purchaseModal.dataset.gameId = gameId;
            
            // Show the modal
            const modal = new bootstrap.Modal(purchaseModal);
            modal.show();
        }
        
        // Remove from wishlist functionality
        function removeFromWishlist(gameId, gameName, gameConsole, button) {
            openRemoveWishlistModal(gameId, gameName, gameConsole, button);
        }
        
        // Open remove wishlist confirmation modal
        function openRemoveWishlistModal(gameId, gameName, gameConsole, button) {
            // Clear any previous error/success messages
            document.getElementById('removeWishlistError').classList.add('d-none');
            document.getElementById('removeWishlistSuccess').classList.add('d-none');
            
            // Set game info in modal
            document.getElementById('removeWishlistGameName').textContent = gameName;
            document.getElementById('removeWishlistGameConsole').textContent = gameConsole;
            
            // Store game data and button reference on the modal for later use
            const removeModal = document.getElementById('removeWishlistModal');
            removeModal.dataset.gameId = gameId;
            removeModal.dataset.gameName = gameName;
            removeModal.dataset.gameConsole = gameConsole;
            removeModal.originalButton = button; // Store button reference
            
            // Show the modal
            const modal = new bootstrap.Modal(removeModal);
            modal.show();
        }
        
        // Handle remove confirmation
        document.getElementById('confirmRemoveWishlistBtn').addEventListener('click', async () => {
            const removeModal = document.getElementById('removeWishlistModal');
            const gameId = removeModal.dataset.gameId;
            const gameName = removeModal.dataset.gameName;
            const gameConsole = removeModal.dataset.gameConsole;
            const button = removeModal.originalButton;
            
            const errorDiv = document.getElementById('removeWishlistError');
            const successDiv = document.getElementById('removeWishlistSuccess');
            const confirmBtn = document.getElementById('confirmRemoveWishlistBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Update button state
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Removing...';
            
            // Disable confirm button during request
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Removing...';
            
            try {
                // Use optimistic removal
                await window.removeFromWishlistOptimistic(gameId, gameName, gameConsole);
                
                // Show success message in modal
                successDiv.textContent = `"${gameName}" has been removed from your wishlist.`;
                successDiv.classList.remove('d-none');
                
                // Update original button
                button.textContent = 'Removed!';
                button.classList.remove('btn-outline-danger');
                button.classList.add('btn-success');
                
                // Auto-close modal after a short delay
                setTimeout(() => {
                    const modalInstance = bootstrap.Modal.getInstance(removeModal);
                    modalInstance.hide();
                }, 1500);
            } catch (error) {
                console.error('Remove from wishlist error:', error);
                
                // Show error message
                errorDiv.textContent = error.message || 'An error occurred while removing the game from your wishlist.';
                errorDiv.classList.remove('d-none');
                
                // Update original button to show failure
                button.textContent = 'Failed';
                button.classList.remove('btn-outline-danger');
                button.classList.add('btn-danger');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-danger');
                    button.classList.add('btn-outline-danger');
                    button.disabled = false;
                }, 2000);
            } finally {
                // Re-enable confirm button
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = '<i class="fas fa-trash-alt me-1"></i>Remove from Wishlist';
            }
        });
        
        // Handle purchase form submission
        document.getElementById('submitPurchaseBtn').addEventListener('click', async () => {
            const purchaseModal = document.getElementById('purchaseModal');
            const gameId = purchaseModal.dataset.gameId;
            
            const purchaseDate = document.getElementById('purchaseDateInput').value;
            const purchaseSource = document.getElementById('purchaseSourceInput').value;
            const purchasePrice = document.getElementById('purchasePriceInput').value;
            
            const errorDiv = document.getElementById('purchaseError');
            const successDiv = document.getElementById('purchaseSuccess');
            const submitBtn = document.getElementById('submitPurchaseBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Validate required fields
            if (!purchaseDate) {
                errorDiv.textContent = 'Purchase date is required.';
                errorDiv.classList.remove('d-none');
                return;
            }
            
            // Disable button during submission
            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing...';
            
            try {
                const purchaseData = {
                    purchase_date: purchaseDate,
                    purchase_source: purchaseSource || null,
                    purchase_price: purchasePrice || null
                };
                
                // Get game info from modal for optimistic update
                const gameName = document.getElementById('purchaseGameName').textContent;
                const gameConsole = document.getElementById('purchaseGameConsole').textContent;
                
                // Use optimistic purchase conversion
                await window.purchaseWishlistGameOptimistic(gameId, gameName, gameConsole, purchaseData);
                
                // Show success message in modal
                successDiv.textContent = 'Game successfully marked as purchased!';
                successDiv.classList.remove('d-none');
                
                // Reset form after short delay
                setTimeout(() => {
                    // Clear the form for next entry
                    document.getElementById('purchaseDateInput').value = new Date().toISOString().split('T')[0];
                    document.getElementById('purchaseSourceInput').value = '';
                    document.getElementById('purchasePriceInput').value = '';
                    
                    // Hide success message after a bit longer
                    setTimeout(() => {
                        successDiv.classList.add('d-none');
                    }, 2000);
                }, 1000);
                
            } catch (error) {
                console.error('Purchase error:', error);
                errorDiv.textContent = error.message || 'An error occurred while marking the game as purchased.';
                errorDiv.classList.remove('d-none');
            } finally {
                // Re-enable button
                submitBtn.disabled = false;
                submitBtn.textContent = '📦 Mark as Purchased';
            }
        });
        
        // Fetch last update dates when game details are shown
        const originalFetchPriceHistory = fetchPriceHistory;
        fetchPriceHistory = function(gameId) {
            originalFetchPriceHistory(gameId);
            fetchLastPriceUpdate(gameId);
        };
        
        // Condition editing functionality
        function openConditionModal(gameId, gameName, gameConsole, currentCondition, isWanted) {
            const modal = document.getElementById('conditionModal');
            const gameNameEl = document.getElementById('conditionGameName');
            const gameConsoleEl = document.getElementById('conditionGameConsole');
            const conditionSelect = document.getElementById('conditionSelect');
            
            // Set game info
            gameNameEl.textContent = gameName;
            gameConsoleEl.textContent = gameConsole;
            
            // Set current condition
            conditionSelect.value = currentCondition;
            
            // Store metadata on modal
            modal.dataset.gameId = gameId;
            modal.dataset.isWanted = isWanted;
            
            // Clear any previous messages
            document.getElementById('conditionError').classList.add('d-none');
            document.getElementById('conditionSuccess').classList.add('d-none');
            
            // Show modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }
        
        // Set up event delegation for condition edit buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('edit-condition-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                const currentCondition = e.target.dataset.currentCondition;
                const isWanted = e.target.dataset.isWanted === 'true';
                
                openConditionModal(gameId, gameName, gameConsole, currentCondition, isWanted);
            }
        });
        
        // Handle condition form submission
        document.getElementById('submitConditionBtn').addEventListener('click', async () => {
            const modal = document.getElementById('conditionModal');
            const gameId = modal.dataset.gameId;
            const isWanted = modal.dataset.isWanted === 'true';
            const newCondition = document.getElementById('conditionSelect').value;
            
            const submitBtn = document.getElementById('submitConditionBtn');
            const errorDiv = document.getElementById('conditionError');
            const successDiv = document.getElementById('conditionSuccess');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Disable button and show loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Updating...';
            
            try {
                const endpoint = isWanted ? `/api/wishlist/${gameId}/condition` : `/api/collection/${gameId}/condition`;
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        condition: newCondition
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to update condition');
                }
                
                const result = await response.json();
                console.log('Condition updated:', result);
                
                // Show success message
                successDiv.textContent = 'Condition updated successfully!';
                successDiv.classList.remove('d-none');
                submitBtn.textContent = 'Updated!';
                
                // Update the display on the page
                const conditionDisplay = document.getElementById(`condition-display-${gameId}`);
                if (conditionDisplay) {
                    conditionDisplay.textContent = newCondition;
                }
                
                // Update the button's data attribute for future edits
                const editBtn = document.querySelector(`[data-game-id="${gameId}"].edit-condition-btn`);
                if (editBtn) {
                    editBtn.dataset.currentCondition = newCondition;
                }
                
                // Close modal after delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                    
                    // Refresh the games list to ensure consistency
                    loadAllGames();
                }, 1500);
                
            } catch (error) {
                console.error('Condition update error:', error);
                errorDiv.textContent = error.message || 'An error occurred while updating the condition.';
                errorDiv.classList.remove('d-none');
            } finally {
                // Re-enable button
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Condition';
            }
        });

        // Set up event delegation for edit details buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('edit-details-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                const currentCondition = e.target.dataset.currentCondition;
                
                openEditDetailsModal(gameId, gameName, gameConsole, currentCondition);
            }
        });

        // Function to open edit details modal
        function openEditDetailsModal(gameId, gameName, gameConsole, currentCondition) {
            const modal = document.getElementById('editDetailsModal');
            const currentName = document.getElementById('editDetailsCurrentName');
            const currentConsole = document.getElementById('editDetailsCurrentConsole');
            const currentConditionSpan = document.getElementById('editDetailsCurrentCondition');
            const nameInput = document.getElementById('editGameName');
            const consoleInput = document.getElementById('editGameConsole');
            const conditionSelect = document.getElementById('editGameCondition');
            const errorDiv = document.getElementById('editDetailsError');
            const successDiv = document.getElementById('editDetailsSuccess');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Set current values
            currentName.textContent = gameName;
            currentConsole.textContent = gameConsole;
            currentConditionSpan.textContent = currentCondition || 'complete';
            nameInput.value = gameName;
            consoleInput.value = gameConsole;
            conditionSelect.value = currentCondition || 'complete';
            
            // Store game ID in modal
            modal.dataset.gameId = gameId;
            
            // Show modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }
        
        // Handle edit details form submission with optimistic updates
        document.getElementById('submitEditDetailsBtn').addEventListener('click', async () => {
            const modal = document.getElementById('editDetailsModal');
            const gameId = parseInt(modal.dataset.gameId);
            const newName = document.getElementById('editGameName').value.trim();
            const newConsole = document.getElementById('editGameConsole').value.trim();
            const newCondition = document.getElementById('editGameCondition').value;
            
            const submitBtn = document.getElementById('submitEditDetailsBtn');
            const errorDiv = document.getElementById('editDetailsError');
            const successDiv = document.getElementById('editDetailsSuccess');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Validate inputs
            if (!newName) {
                errorDiv.textContent = 'Game name is required.';
                errorDiv.classList.remove('d-none');
                return;
            }
            
            if (!newConsole) {
                errorDiv.textContent = 'Console is required.';
                errorDiv.classList.remove('d-none');
                return;
            }
            
            // Disable button and show loading state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Updating...';
            
            try {
                // Use optimistic update function
                await window.editGameDetailsOptimistic(gameId, newName, newConsole, newCondition);
                
                // Show success message
                successDiv.textContent = 'Game details updated successfully!';
                successDiv.classList.remove('d-none');
                submitBtn.textContent = 'Updated!';
                
                // Close modal after delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1500);
                
            } catch (error) {
                console.error('Game details update error:', error);
                errorDiv.textContent = error.message || 'An error occurred while updating the game details.';
                errorDiv.classList.remove('d-none');
            } finally {
                // Re-enable button
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Details';
            }
        });

        // Helper function to update game card UI for sale status
        function updateGameCardForSale(gameId, saleData) {
            console.log('🚀 Updating game card for sale, gameId:', gameId);
            
            // Find the game row and details
            const gameRow = document.querySelector(`tr.game-row[data-game-id="${gameId}"]`);
            const gameDetails = document.querySelector(`div.game-details[data-game-id="${gameId}"]`);
            
            if (!gameRow || !gameDetails) {
                console.warn('Game elements not found for ID:', gameId, { gameRow: !!gameRow, gameDetails: !!gameDetails });
                return;
            }
            
            // Update status icon in the table row (first column)
            const statusIcon = gameRow.querySelector('.status-col');
            if (statusIcon) {
                statusIcon.textContent = '💰';
            }
            
            // Update status text in the details section
            const statusElements = gameDetails.querySelectorAll('dd');
            // The status is the second dd element (Console, Status, Condition, ...)
            if (statusElements && statusElements.length >= 2) {
                statusElements[1].textContent = 'For Sale';
            }
            
            // Update action buttons - find or create buttons
            // Find the Actions section specifically
            const actionsDt = Array.from(gameDetails.querySelectorAll('dt')).find(dt => dt.textContent.trim() === 'Actions');
            const actionsContainer = actionsDt ? actionsDt.nextElementSibling : null;
            let markButton = gameDetails.querySelector('.mark-for-sale-btn');
            let unmarkButton = gameDetails.querySelector('.unmark-for-sale-btn');
            
            // Hide mark button if it exists
            if (markButton) {
                markButton.style.display = 'none';
                console.log('✅ Hid mark for sale button');
            }
            
            // Show unmark button if it exists, otherwise create it
            if (unmarkButton) {
                unmarkButton.style.display = 'inline-block';
                console.log('✅ Showed existing unmark for sale button');
            } else if (actionsContainer) {
                // Create unmark button dynamically
                unmarkButton = document.createElement('button');
                unmarkButton.className = 'btn btn-sm btn-outline-warning unmark-for-sale-btn';
                unmarkButton.setAttribute('data-game-id', gameId);
                unmarkButton.setAttribute('data-game-name', saleData.gameName || 'Unknown');
                unmarkButton.setAttribute('data-game-console', saleData.gameConsole || 'Unknown');
                unmarkButton.style.cssText = 'font-size: 0.75rem; padding: 0.2rem 0.5rem; margin-left: 0.5rem;';
                unmarkButton.innerHTML = '🚫 Unmark for Sale';
                
                actionsContainer.prepend(unmarkButton);
                console.log('✅ Created new unmark for sale button');
            }
            
            // Add sale information to the details if not already present
            // Look for existing sale info section or create one
            let saleInfoSection = gameDetails.querySelector('.sale-info-section');
            if (!saleInfoSection && (saleData.asking_price || saleData.notes)) {
                // Create a new section for sale information
                const dlElement = gameDetails.querySelector('dl');
                if (dlElement) {
                    const saleDiv = document.createElement('div');
                    saleDiv.className = 'sale-info-section';
                    saleDiv.innerHTML = `
                        <dt>Sale Information</dt>
                        <dd class="sale-info"></dd>
                    `;
                    dlElement.appendChild(saleDiv);
                    saleInfoSection = saleDiv;
                }
            }
            
            // Update sale information content
            const saleInfo = saleInfoSection?.querySelector('.sale-info');
            if (saleInfo) {
                let saleInfoHTML = '';
                if (saleData.asking_price) {
                    saleInfoHTML += `Asking Price: $${saleData.asking_price}<br>`;
                }
                if (saleData.notes) {
                    saleInfoHTML += `Notes: ${saleData.notes}<br>`;
                }
                saleInfoHTML += `Date Marked: ${saleData.date_marked_for_sale}`;
                saleInfo.innerHTML = saleInfoHTML;
            }
            
            console.log('✅ Updated game card UI for sale status:', gameId);
        }
        
        // Helper function to update game card UI when unmarking for sale
        function updateGameCardUnmarkForSale(gameId) {
            console.log('🚀 Updating game card for unmark sale, gameId:', gameId);
            
            // Find the game row and details
            const gameRow = document.querySelector(`tr.game-row[data-game-id="${gameId}"]`);
            const gameDetails = document.querySelector(`div.game-details[data-game-id="${gameId}"]`);
            
            if (!gameRow || !gameDetails) {
                console.warn('Game elements not found for ID:', gameId, { gameRow: !!gameRow, gameDetails: !!gameDetails });
                return;
            }
            
            // Update status icon in the table row (back to purchased)
            const statusIcon = gameRow.querySelector('.status-col');
            if (statusIcon) {
                statusIcon.textContent = '✓';
            }
            
            // Update status text in the details section
            const statusElements = gameDetails.querySelectorAll('dd');
            // The status is the second dd element (Console, Status, Condition, ...)
            if (statusElements && statusElements.length >= 2) {
                statusElements[1].textContent = 'Purchased';
            }
            
            // Update action buttons - find or create buttons
            // Find the Actions section specifically
            const actionsDt = Array.from(gameDetails.querySelectorAll('dt')).find(dt => dt.textContent.trim() === 'Actions');
            const actionsContainer = actionsDt ? actionsDt.nextElementSibling : null;
            let markButton = gameDetails.querySelector('.mark-for-sale-btn');
            let unmarkButton = gameDetails.querySelector('.unmark-for-sale-btn');
            
            // Hide unmark button if it exists
            if (unmarkButton) {
                unmarkButton.style.display = 'none';
                console.log('✅ Hid unmark for sale button');
            }
            
            // Show mark button if it exists, otherwise create it
            if (markButton) {
                markButton.style.display = 'inline-block';
                console.log('✅ Showed existing mark for sale button');
            } else if (actionsContainer) {
                // Create mark button dynamically
                markButton = document.createElement('button');
                markButton.className = 'btn btn-sm btn-success mark-for-sale-btn';
                markButton.setAttribute('data-game-id', gameId);
                markButton.setAttribute('data-game-name', 'Unknown'); // We don't have this info in unmark
                markButton.setAttribute('data-game-console', 'Unknown');
                markButton.style.cssText = 'font-size: 0.75rem; padding: 0.2rem 0.5rem; margin-left: 0.5rem;';
                markButton.innerHTML = '💰 Mark for Sale';
                
                actionsContainer.prepend(markButton);
                console.log('✅ Created new mark for sale button');
            }
            
            // Remove sale information section if it exists
            const saleInfoSection = gameDetails.querySelector('.sale-info-section');
            if (saleInfoSection) {
                saleInfoSection.remove();
                console.log('✅ Removed sale info section');
            }
            
            console.log('✅ Updated game card UI for unmark sale status:', gameId);
        }

        // Mark for Sale functionality
        function openMarkForSaleModal(gameId, gameName, gameConsole) {
            const modal = document.getElementById('markForSaleModal');
            const gameInfo = document.getElementById('markForSaleGameInfo');
            const submitBtn = document.getElementById('confirmMarkForSaleBtn');
            
            modal.dataset.gameId = gameId;
            modal.dataset.gameName = gameName;
            modal.dataset.gameConsole = gameConsole;
            
            gameInfo.textContent = `${gameName} (${gameConsole})`;
            
            // Clear previous values
            document.getElementById('askingPriceInput').value = '';
            document.getElementById('saleNotesInput').value = '';
            
            // Clear messages
            document.getElementById('markForSaleError').classList.add('d-none');
            document.getElementById('markForSaleSuccess').classList.add('d-none');
            
            // Reset submit button state
            submitBtn.disabled = false;
            submitBtn.textContent = 'Mark for Sale';
            
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }

        // Set up event delegation for mark for sale buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('mark-for-sale-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                openMarkForSaleModal(gameId, gameName, gameConsole);
            }
        });

        // Handle mark for sale confirmation (with optimistic updates)
        document.getElementById('confirmMarkForSaleBtn').addEventListener('click', async () => {
            const modal = document.getElementById('markForSaleModal');
            const gameId = modal.dataset.gameId;
            const gameName = modal.dataset.gameName;
            const gameConsole = modal.dataset.gameConsole;
            const askingPrice = document.getElementById('askingPriceInput').value;
            const saleNotes = document.getElementById('saleNotesInput').value;
            const errorDiv = document.getElementById('markForSaleError');
            const successDiv = document.getElementById('markForSaleSuccess');
            const submitBtn = document.getElementById('confirmMarkForSaleBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Update button state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Marking for Sale...';
            
            // Prepare optimistic update data
            const optimisticData = {
                asking_price: askingPrice ? parseFloat(askingPrice) : null,
                notes: saleNotes.trim() || null,
                sale_status: 'for_sale',
                date_marked_for_sale: new Date().toISOString().split('T')[0]
            };
            
            // UI update function for optimistic changes
            const applyOptimisticUI = (game) => {
                console.log('🚀 Applying optimistic mark for sale UI for game:', gameId);
                
                // Update game state
                const currentGame = window.gameStateManager.getGame(gameId);
                if (currentGame) {
                    const updatedGame = {
                        ...currentGame,
                        ...optimisticData
                    };
                    window.gameStateManager.updateGame(updatedGame);
                }
                
                // Update UI elements immediately
                updateGameCardForSale(gameId, optimisticData);
                
                // Show success in modal
                successDiv.textContent = 'Game marked for sale successfully!';
                successDiv.classList.remove('d-none');
                submitBtn.textContent = 'Marked for Sale!';
                
                // Close modal after short delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1500);
            };
            
            // API function
            const markForSaleAPI = async () => {
                const requestBody = {};
                if (askingPrice) {
                    requestBody.asking_price = parseFloat(askingPrice);
                }
                if (saleNotes.trim()) {
                    requestBody.notes = saleNotes.trim();
                }
                
                const response = await fetch(`/api/game/${gameId}/mark_for_sale`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to mark game for sale');
                }
                
                return await response.json();
            };
            
            // Error handling function
            const handleError = (error) => {
                console.error('❌ Mark for sale failed:', error);
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('d-none');
                successDiv.classList.add('d-none');
                
                // Reset button state
                submitBtn.disabled = false;
                submitBtn.textContent = 'Mark for Sale';
            };
            
            // Apply simplified optimistic update
            try {
                console.log('🚀 Applying optimistic mark for sale...');
                
                // 1. Apply immediate UI changes
                applyOptimisticUI();
                
                // 2. Call API in background
                const result = await markForSaleAPI();
                
                // 3. Update state manager on success
                const currentGame = window.gameStateManager.getGame(gameId);
                if (currentGame) {
                    const updatedGame = {
                        ...currentGame,
                        is_for_sale: true,
                        asking_price: askingPrice,
                        sale_notes: saleNotes,
                        date_marked_for_sale: new Date().toISOString().split('T')[0]
                    };
                    window.gameStateManager.updateGame(updatedGame);
                }
                
                console.log('✅ Mark for sale completed successfully');
                
            } catch (error) {
                console.error('❌ Mark for sale failed, rolling back...', error);
                
                // Rollback UI changes
                updateGameCardUnmarkForSale(gameId);
                
                // Handle error
                handleError(error);
            }
        });

        // Set up event delegation for unmark for sale buttons (with optimistic updates)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('unmark-for-sale-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                
                // Show unmark for sale modal
                const modal = document.getElementById('unmarkForSaleModal');
                const gameInfo = document.getElementById('unmarkForSaleGameInfo');
                const errorDiv = document.getElementById('unmarkForSaleError');
                
                // Set game info
                gameInfo.textContent = `${gameName} (${gameConsole})`;
                
                // Clear any previous errors
                errorDiv.classList.add('d-none');
                
                // Store game info in modal for confirmation
                modal.dataset.gameId = gameId;
                modal.dataset.gameName = gameName;
                modal.dataset.gameConsole = gameConsole;
                
                // Show modal
                const bootstrapModal = new bootstrap.Modal(modal);
                bootstrapModal.show();
            }
        });
        
        // Handle unmark for sale modal confirmation
        document.getElementById('confirmUnmarkForSaleBtn').addEventListener('click', async () => {
            const modal = document.getElementById('unmarkForSaleModal');
            const gameId = modal.dataset.gameId;
            const gameName = modal.dataset.gameName;
            const gameConsole = modal.dataset.gameConsole;
            const errorDiv = document.getElementById('unmarkForSaleError');
            const submitBtn = document.getElementById('confirmUnmarkForSaleBtn');
            
            // Clear any errors
            errorDiv.classList.add('d-none');
            
            // Disable button and show loading state
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Unmarking...';
            
            try {
                // Call the unmark function
                await unmarkForSale(gameId, gameName, gameConsole);
                
                // Close modal after short delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1000);
                
            } catch (error) {
                console.error('Unmark for sale error:', error);
                errorDiv.textContent = error.message || 'An error occurred while unmarking the game for sale.';
                errorDiv.classList.remove('d-none');
            } finally {
                // Re-enable button
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-times me-1"></i>Unmark for Sale';
            }
        });

        // Unmark for sale function (with optimistic updates)
        async function unmarkForSale(gameId, gameName, gameConsole) {
            // UI update function for optimistic changes
            const applyOptimisticUI = (game) => {
                console.log('🚀 Applying optimistic unmark for sale UI for game:', gameId);
                
                // Update game state
                const currentGame = window.gameStateManager.getGame(gameId);
                if (currentGame) {
                    const updatedGame = {
                        ...currentGame,
                        sale_status: null,
                        asking_price: null,
                        notes: null,
                        date_marked_for_sale: null
                    };
                    window.gameStateManager.updateGame(updatedGame);
                }
                
                // Update UI elements immediately
                updateGameCardUnmarkForSale(gameId);
                
                // Show success toast
                window.errorHandler.showSuccessToast(`${gameName} unmarked for sale! ✅`);
            };
            
            // API function
            const unmarkForSaleAPI = async () => {
                const response = await fetch(`/api/game/${gameId}/unmark_for_sale`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to unmark game for sale');
                }
                
                return await response.json();
            };
            
            // Error handling function
            const handleError = (error) => {
                console.error('❌ Unmark for sale failed:', error);
                window.errorHandler.showErrorToast(`Failed to unmark ${gameName} for sale: ${error.message}`);
            };
            
            // Apply simplified optimistic update
            try {
                console.log('🚀 Applying optimistic unmark for sale...');
                
                // 1. Apply immediate UI changes
                applyOptimisticUI();
                
                // 2. Call API in background
                const result = await unmarkForSaleAPI();
                
                // 3. Update state manager on success
                const currentGame = window.gameStateManager.getGame(gameId);
                if (currentGame) {
                    const updatedGame = {
                        ...currentGame,
                        is_for_sale: false,
                        asking_price: null,
                        sale_notes: null,
                        date_marked_for_sale: null
                    };
                    window.gameStateManager.updateGame(updatedGame);
                }
                
                console.log('✅ Unmark for sale completed successfully');
                
            } catch (error) {
                console.error('❌ Unmark for sale failed, rolling back...', error);
                
                // Rollback UI changes - mark back for sale
                const saleData = {
                    asking_price: currentGame?.asking_price || 0,
                    notes: currentGame?.sale_notes || '',
                    date_marked_for_sale: currentGame?.date_marked_for_sale || new Date().toISOString().split('T')[0]
                };
                updateGameCardForSale(gameId, saleData);
                
                // Handle error
                handleError(error);
            }
        }

        // Mark as Lent functionality
        function openMarkLentModal(gameId, gameName, gameConsole) {
            const modal = document.getElementById('markLentModal');
            const gameInfo = document.getElementById('markLentGameInfo');
            
            modal.dataset.gameId = gameId;
            modal.dataset.gameName = gameName;
            modal.dataset.gameConsole = gameConsole;
            
            gameInfo.textContent = `${gameName} (${gameConsole})`;
            
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('lentDateInput').value = today;
            
            // Clear previous values
            document.getElementById('lentToInput').value = '';
            
            // Clear messages
            document.getElementById('markLentError').classList.add('d-none');
            document.getElementById('markLentSuccess').classList.add('d-none');
            
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }

        // Set up event delegation for mark as lent buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('mark-lent-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                openMarkLentModal(gameId, gameName, gameConsole);
            }
        });

        // Handle mark as lent confirmation
        document.getElementById('confirmMarkLentBtn').addEventListener('click', async () => {
            const modal = document.getElementById('markLentModal');
            const gameId = modal.dataset.gameId;
            const gameName = modal.dataset.gameName;
            const gameConsole = modal.dataset.gameConsole;
            const lentDate = document.getElementById('lentDateInput').value;
            const lentTo = document.getElementById('lentToInput').value.trim();
            const errorDiv = document.getElementById('markLentError');
            const successDiv = document.getElementById('markLentSuccess');
            const submitBtn = document.getElementById('confirmMarkLentBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Validate inputs
            if (!lentDate) {
                errorDiv.textContent = 'Lent date is required';
                errorDiv.classList.remove('d-none');
                return;
            }
            
            if (!lentTo) {
                errorDiv.textContent = 'Lent to field is required';
                errorDiv.classList.remove('d-none');
                return;
            }
            
            // Update button state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Marking as Lent...';
            
            try {
                const lentData = {
                    lent_date: lentDate,
                    lent_to: lentTo
                };
                
                // Use optimistic update
                await window.markGameAsLentOptimistic(gameId, gameName, gameConsole, lentData);
                
                // Show success message in modal
                successDiv.textContent = 'Game marked as lent out successfully!';
                successDiv.classList.remove('d-none');
                
                // Update button
                submitBtn.textContent = 'Marked as Lent!';
                
                // Close modal after short delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1500);
                
            } catch (error) {
                console.error('Error marking game as lent out:', error);
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('d-none');
                
                // Reset button
                submitBtn.disabled = false;
                submitBtn.textContent = 'Mark as Lent';
            }
        });

        // Unmark as Lent functionality
        function openUnmarkLentModal(gameId, gameName, gameConsole, lentTo) {
            const modal = document.getElementById('unmarkLentModal');
            const gameInfo = document.getElementById('unmarkLentGameInfo');
            const lentToInfo = document.getElementById('unmarkLentToInfo');
            
            modal.dataset.gameId = gameId;
            modal.dataset.gameName = gameName;
            modal.dataset.gameConsole = gameConsole;
            
            gameInfo.textContent = `${gameName} (${gameConsole})`;
            lentToInfo.textContent = lentTo;
            
            // Clear messages
            document.getElementById('unmarkLentError').classList.add('d-none');
            document.getElementById('unmarkLentSuccess').classList.add('d-none');
            
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }

        // Set up event delegation for unmark as lent buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('unmark-lent-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                const lentTo = e.target.dataset.lentTo;
                openUnmarkLentModal(gameId, gameName, gameConsole, lentTo);
            }
        });

        // Handle unmark as lent confirmation
        document.getElementById('confirmUnmarkLentBtn').addEventListener('click', async () => {
            const modal = document.getElementById('unmarkLentModal');
            const gameId = modal.dataset.gameId;
            const gameName = modal.dataset.gameName;
            const gameConsole = modal.dataset.gameConsole;
            const errorDiv = document.getElementById('unmarkLentError');
            const successDiv = document.getElementById('unmarkLentSuccess');
            const submitBtn = document.getElementById('confirmUnmarkLentBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Update button state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Marking as Returned...';
            
            try {
                // Use optimistic update
                await window.unmarkGameAsLentOptimistic(gameId, gameName, gameConsole);
                
                // Show success message in modal
                successDiv.textContent = 'Game marked as returned successfully!';
                successDiv.classList.remove('d-none');
                
                // Update button
                submitBtn.textContent = 'Marked as Returned!';
                
                // Close modal after short delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1500);
                
            } catch (error) {
                console.error('Error marking game as returned:', error);
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('d-none');
                
                // Reset button
                submitBtn.disabled = false;
                submitBtn.textContent = 'Mark as Returned';
            }
        });

        // Remove from Collection functionality
        function openRemoveFromCollectionModal(gameId, purchasedGameId, gameName, gameConsole) {
            const modal = document.getElementById('removeFromCollectionModal');
            const gameInfo = document.getElementById('removeGameInfo');
            const errorDiv = document.getElementById('removeCollectionError');
            const successDiv = document.getElementById('removeCollectionSuccess');
            
            // Set modal data
            modal.dataset.gameId = gameId;
            modal.dataset.purchasedGameId = purchasedGameId;
            modal.dataset.gameName = gameName;
            modal.dataset.gameConsole = gameConsole;
            
            // Update modal content
            gameInfo.textContent = `${gameName} (${gameConsole})`;
            
            // Clear any previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Reset button state
            const submitBtn = document.getElementById('confirmRemoveFromCollectionBtn');
            submitBtn.disabled = false;
            submitBtn.textContent = 'Remove from Collection';
            
            // Show modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }

        // Set up event delegation for remove from collection buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('remove-from-collection-btn')) {
                e.preventDefault();
                const gameId = e.target.dataset.gameId;
                const purchasedGameId = e.target.dataset.purchasedGameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                
                openRemoveFromCollectionModal(gameId, purchasedGameId, gameName, gameConsole);
            }
        });

        // Handle remove from collection confirmation
        document.getElementById('confirmRemoveFromCollectionBtn').addEventListener('click', async () => {
            const modal = document.getElementById('removeFromCollectionModal');
            const gameId = modal.dataset.gameId;
            const purchasedGameId = modal.dataset.purchasedGameId;
            const gameName = modal.dataset.gameName;
            const gameConsole = modal.dataset.gameConsole;
            
            const errorDiv = document.getElementById('removeCollectionError');
            const successDiv = document.getElementById('removeCollectionSuccess');
            const submitBtn = document.getElementById('confirmRemoveFromCollectionBtn');
            
            // Clear previous messages
            errorDiv.classList.add('d-none');
            successDiv.classList.add('d-none');
            
            // Update button state
            submitBtn.disabled = true;
            submitBtn.textContent = 'Removing from Collection...';
            
            try {
                // Use optimistic removal
                await window.removeFromCollectionOptimistic(purchasedGameId, gameId, gameName, gameConsole);
                
                // Show success message
                successDiv.textContent = 'Game removed from collection successfully!';
                successDiv.classList.remove('d-none');
                
                // Update button
                submitBtn.textContent = 'Removed from Collection!';
                
                // Close modal after delay
                setTimeout(() => {
                    const bootstrapModal = bootstrap.Modal.getInstance(modal);
                    bootstrapModal.hide();
                }, 1500);
                
            } catch (error) {
                console.error('Error removing game from collection:', error);
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('d-none');
                
                // Reset button
                submitBtn.disabled = false;
                submitBtn.textContent = 'Remove from Collection';
            }
        });

        // Photo Upload Modal Functionality
        let currentGameIdForPhotos = null;
        let selectedPhotoFiles = [];
        let existingGamePhotos = [];

        // Handle photo upload button clicks
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('add-photos-btn')) {
                e.preventDefault();
                e.stopPropagation();
                
                const gameId = e.target.dataset.gameId;
                const gameName = e.target.dataset.gameName;
                const gameConsole = e.target.dataset.gameConsole;
                
                if (gameId && gameName && gameConsole) {
                    openPhotoUploadModal(gameId, gameName, gameConsole);
                }
            }
        });

        async function openPhotoUploadModal(gameId, gameName, gameConsole) {
            currentGameIdForPhotos = gameId;
            
            // Set game info in modal
            document.getElementById('photoUploadGameName').textContent = gameName;
            document.getElementById('photoUploadGameConsole').textContent = gameConsole;
            
            // Reset modal state
            resetPhotoUploadModal();
            
            // Load existing photos
            await loadExistingPhotos(gameId);
            
            // Update photo count display
            updatePhotoCountDisplay();
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('photoUploadModal'));
            modal.show();
        }

        function resetPhotoUploadModal() {
            selectedPhotoFiles = [];
            document.getElementById('photoFiles').value = '';
            document.getElementById('photoPreviewArea').style.display = 'none';
            document.getElementById('photoPreviewArea').innerHTML = '<div class="col-12"><h6 class="text-muted">Selected Photos:</h6></div>';
            document.getElementById('uploadProgressArea').style.display = 'none';
            document.getElementById('uploadPhotosBtn').disabled = true;
            document.getElementById('photoUploadError').classList.add('d-none');
            document.getElementById('photoUploadSuccess').classList.add('d-none');
            
            // Check if camera is available (mobile devices)
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                document.getElementById('openCameraBtn').style.display = 'inline-block';
            }
        }

        async function loadExistingPhotos(gameId) {
            try {
                const response = await fetch(`/api/game/${gameId}/photos`);
                const data = await response.json();
                
                if (response.ok) {
                    existingGamePhotos = data.photos || [];
                    displayExistingPhotos();
                } else {
                    console.error('Failed to load photos:', data.message);
                }
            } catch (error) {
                console.error('Error loading photos:', error);
            }
        }

        function displayExistingPhotos() {
            const photosSection = document.getElementById('existingPhotosSection');
            const photosList = document.getElementById('existingPhotosList');
            const countBadge = document.getElementById('photoCountBadge');
            
            if (existingGamePhotos.length === 0) {
                photosSection.style.display = 'none';
                return;
            }
            
            photosSection.style.display = 'block';
            countBadge.textContent = `${existingGamePhotos.length} photo${existingGamePhotos.length === 1 ? '' : 's'}`;
            
            photosList.innerHTML = existingGamePhotos.map(photo => `
                <div class="col-lg-3 col-md-4 col-sm-6 col-6">
                    <div class="card">
                        <div class="position-relative">
                            <img src="/api/photos/${photo.id}/view" class="card-img-top" style="height: 120px; object-fit: cover; cursor: pointer;" 
                                 onclick="openPhotoViewer(${photo.id}, '/api/photos/${photo.id}/view', '${photo.original_filename}')"
                                 alt="${photo.original_filename}">
                            <div class="position-absolute top-0 end-0 p-1">
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="deletePhoto(${photo.id}, '${photo.original_filename}')"
                                        title="Delete Photo">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <div class="card-body p-2">
                            <small class="text-muted d-block text-truncate" title="${photo.original_filename}">
                                ${photo.original_filename}
                            </small>
                            <small class="text-muted">${formatFileSize(photo.file_size)}</small>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // File selection handlers
        document.getElementById('selectFilesBtn').addEventListener('click', function() {
            document.getElementById('photoFiles').click();
        });

        document.getElementById('photoFiles').addEventListener('change', function(e) {
            handleFileSelection(e.target.files);
        });

        document.getElementById('openCameraBtn').addEventListener('click', function() {
            // For camera capture, we'll use the file input with capture attribute
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.capture = 'camera';
            input.multiple = true;
            input.addEventListener('change', function(e) {
                handleFileSelection(e.target.files);
            });
            input.click();
        });

        function handleFileSelection(files) {
            const maxSize = 5 * 1024 * 1024; // 5MB
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
            const validFiles = [];
            const errors = [];

            Array.from(files).forEach(file => {
                if (!allowedTypes.includes(file.type)) {
                    errors.push(`${file.name}: Invalid file type. Only JPEG, PNG, and WebP are allowed.`);
                    return;
                }
                
                if (file.size > maxSize) {
                    errors.push(`${file.name}: File too large. Maximum size is 5MB.`);
                    return;
                }
                
                validFiles.push(file);
            });

            if (errors.length > 0) {
                const errorAlert = document.getElementById('photoUploadError');
                errorAlert.textContent = 'File Validation Errors:\n' + errors.join('\n');
                errorAlert.classList.remove('d-none');
                return;
            }

            // Filter out duplicate files based on name and size
            const newFiles = validFiles.filter(newFile => {
                return !selectedPhotoFiles.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
            });
            
            // Check photo limit (20 photos per game including existing photos)
            const maxPhotos = 20;
            const currentPhotoCount = existingGamePhotos.length;
            const maxNewPhotos = maxPhotos - currentPhotoCount - selectedPhotoFiles.length;
            
            let finalFiles = newFiles;
            if (newFiles.length > maxNewPhotos) {
                finalFiles = newFiles.slice(0, maxNewPhotos);
                const errorAlert = document.getElementById('photoUploadError');
                errorAlert.textContent = `Photo limit: Only ${maxNewPhotos} more photos can be added (${currentPhotoCount} existing, ${selectedPhotoFiles.length} selected, ${maxPhotos} max).`;
                errorAlert.classList.remove('d-none');
            } else if (newFiles.length < validFiles.length) {
                const duplicateCount = validFiles.length - newFiles.length;
                const errorAlert = document.getElementById('photoUploadError');
                errorAlert.textContent = `Note: ${duplicateCount} duplicate file(s) were skipped.`;
                errorAlert.classList.remove('d-none');
            }
            
            // Add new files to existing selection instead of replacing
            selectedPhotoFiles = selectedPhotoFiles.concat(finalFiles);
            displayPhotoPreview();
            updatePhotoCountDisplay();
            
            document.getElementById('uploadPhotosBtn').disabled = selectedPhotoFiles.length === 0;
        }

        function displayPhotoPreview() {
            const previewArea = document.getElementById('photoPreviewArea');
            
            if (selectedPhotoFiles.length === 0) {
                previewArea.style.display = 'none';
                return;
            }

            previewArea.style.display = 'block';
            
            // Use flexbox layout for reliable horizontal arrangement
            previewArea.innerHTML = `
                <div class="col-12 mb-3">
                    <h6 class="text-muted">Selected Photos (${selectedPhotoFiles.length}):</h6>
                </div>
                <div class="col-12">
                    <div class="d-flex flex-wrap gap-3">
                        ${selectedPhotoFiles.map((file, index) => `
                            <div style="flex: 0 0 auto; width: 200px;">
                                <div class="card">
                                    <div class="position-relative">
                                        <img src="${URL.createObjectURL(file)}" class="card-img-top" 
                                             style="height: 120px; object-fit: cover;" alt="${file.name}">
                                        <div class="position-absolute top-0 end-0 p-1">
                                            <button class="btn btn-sm btn-outline-danger" 
                                                    onclick="removeSelectedFile(${index})"
                                                    title="Remove">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="card-body p-2">
                                        <small class="text-muted d-block text-truncate" title="${file.name}">
                                            ${file.name}
                                        </small>
                                        <small class="text-muted">${formatFileSize(file.size)}</small>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function removeSelectedFile(index) {
            selectedPhotoFiles.splice(index, 1);
            displayPhotoPreview();
            updatePhotoCountDisplay();
            document.getElementById('uploadPhotosBtn').disabled = selectedPhotoFiles.length === 0;
        }
        
        function updatePhotoCountDisplay() {
            const maxPhotos = 20;
            const currentCount = existingGamePhotos.length;
            const selectedCount = selectedPhotoFiles.length;
            const remainingSlots = maxPhotos - currentCount - selectedCount;
            
            const photoCountElement = document.getElementById('photoUploadPhotoCount');
            photoCountElement.textContent = `Photos: ${currentCount} existing, ${selectedCount} selected, ${remainingSlots} more can be added (${maxPhotos} max)`;
        }

        // Upload photos
        document.getElementById('uploadPhotosBtn').addEventListener('click', async function() {
            if (selectedPhotoFiles.length === 0) return;
            
            try {
                await uploadPhotos();
            } catch (error) {
                console.error('Upload error:', error);
                const errorAlert = document.getElementById('photoUploadError');
                errorAlert.textContent = 'Upload failed: ' + error.message;
                errorAlert.classList.remove('d-none');
                
                // Re-enable upload button and hide progress on error
                document.getElementById('uploadPhotosBtn').disabled = selectedPhotoFiles.length === 0;
                document.getElementById('uploadProgressArea').style.display = 'none';
                
                // Show retry hint
                if (selectedPhotoFiles.length > 0) {
                    const errorAlert = document.getElementById('photoUploadError');
                    errorAlert.textContent += ' You can try uploading again.';
                }
            }
        });

        async function uploadPhotos() {
            const progressArea = document.getElementById('uploadProgressArea');
            const progressBar = document.getElementById('uploadProgressBar');
            const progressText = document.getElementById('uploadProgressText');
            
            progressArea.style.display = 'block';
            document.getElementById('uploadPhotosBtn').disabled = true;
            
            let completedUploads = 0;
            const totalUploads = selectedPhotoFiles.length;
            
            for (const file of selectedPhotoFiles) {
                try {
                    // Generate S3 key
                    const s3Key = `photos/${currentGameIdForPhotos}/${Date.now()}_${Math.random().toString(36).substring(2, 10)}_${file.name}`;
                    
                    // Get presigned URL
                    const urlResponse = await fetch(`/api/game/${currentGameIdForPhotos}/photos/upload-url`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            files: [{
                                filename: file.name,
                                content_type: file.type,
                                file_size: file.size
                            }]
                        })
                    });
                    
                    const urlData = await urlResponse.json();
                    if (!urlResponse.ok) throw new Error(urlData.error || 'Failed to get upload URL');
                    
                    // Get the upload URL data (first item since we send one file at a time)
                    const uploadInfo = urlData.upload_urls[0];
                    
                    // Upload to S3
                    const formData = new FormData();
                    Object.keys(uploadInfo.fields).forEach(key => {
                        formData.append(key, uploadInfo.fields[key]);
                    });
                    formData.append('file', file);
                    
                    const uploadResponse = await fetch(uploadInfo.upload_url, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!uploadResponse.ok) throw new Error('S3 upload failed');
                    
                    // Register photo in database
                    const registerResponse = await fetch(`/api/game/${currentGameIdForPhotos}/photos`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            uploads: [{
                                s3_key: uploadInfo.s3_key,
                                original_filename: file.name,
                                file_size: file.size,
                                content_type: file.type
                            }]
                        })
                    });
                    
                    if (!registerResponse.ok) {
                        const registerData = await registerResponse.json();
                        throw new Error(registerData.message || 'Failed to register photo');
                    }
                    
                    completedUploads++;
                    const progress = Math.round((completedUploads / totalUploads) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${progress}%`;
                    
                } catch (error) {
                    console.error('Error uploading file:', file.name, error);
                    throw new Error(`Failed to upload ${file.name}: ${error.message}`);
                }
            }
            
            // Upload complete
            const successAlert = document.getElementById('photoUploadSuccess');
            successAlert.textContent = `Successfully uploaded ${totalUploads} photo${totalUploads === 1 ? '' : 's'}!`;
            successAlert.classList.remove('d-none');
            
            // Reset and reload
            selectedPhotoFiles = [];
            document.getElementById('photoFiles').value = '';
            displayPhotoPreview();
            await loadExistingPhotos(currentGameIdForPhotos);
            
            // Update photo count in expanded card if visible
            await loadPhotoCount(currentGameIdForPhotos);
            
            progressArea.style.display = 'none';
            document.getElementById('uploadPhotosBtn').disabled = true;
        }

        // Photo viewer functions
        let currentPhotoIndex = 0;
        
        function openPhotoViewer(photoId, photoUrl, filename) {
            currentPhotoIndex = existingGamePhotos.findIndex(photo => photo.id === photoId);
            
            document.getElementById('photoViewerImage').src = photoUrl;
            document.getElementById('photoViewerInfo').textContent = filename;
            
            // Update navigation buttons
            document.getElementById('prevPhotoBtn').style.display = existingGamePhotos.length > 1 ? 'inline-block' : 'none';
            document.getElementById('nextPhotoBtn').style.display = existingGamePhotos.length > 1 ? 'inline-block' : 'none';
            
            // Update photo counter
            updatePhotoCounter();
            
            // Set delete button
            document.getElementById('deletePhotoBtn').onclick = () => deletePhoto(photoId, filename);
            
            const modal = new bootstrap.Modal(document.getElementById('photoViewerModal'));
            
            // Enable keyboard navigation when modal shows
            modal.show();
            enablePhotoViewerKeyboard();
            
            // Disable keyboard navigation when modal hides
            document.getElementById('photoViewerModal').addEventListener('hidden.bs.modal', disablePhotoViewerKeyboard, { once: true });
        }

        document.getElementById('prevPhotoBtn').addEventListener('click', function() {
            currentPhotoIndex = (currentPhotoIndex - 1 + existingGamePhotos.length) % existingGamePhotos.length;
            const photo = existingGamePhotos[currentPhotoIndex];
            document.getElementById('photoViewerImage').src = `/api/photos/${photo.id}/view`;
            document.getElementById('photoViewerInfo').textContent = photo.original_filename;
            document.getElementById('deletePhotoBtn').onclick = () => deletePhoto(photo.id, photo.original_filename);
            updatePhotoCounter();
        });

        document.getElementById('nextPhotoBtn').addEventListener('click', function() {
            currentPhotoIndex = (currentPhotoIndex + 1) % existingGamePhotos.length;
            const photo = existingGamePhotos[currentPhotoIndex];
            document.getElementById('photoViewerImage').src = `/api/photos/${photo.id}/view`;
            document.getElementById('photoViewerInfo').textContent = photo.original_filename;
            document.getElementById('deletePhotoBtn').onclick = () => deletePhoto(photo.id, photo.original_filename);
            updatePhotoCounter();
        });

        async function deletePhoto(photoId, filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"?`)) return;
            
            try {
                const response = await fetch(`/api/game/${currentGameIdForPhotos}/photos/${photoId}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Close viewer if it's open
                    const viewerModal = bootstrap.Modal.getInstance(document.getElementById('photoViewerModal'));
                    if (viewerModal) viewerModal.hide();
                    
                    // Reload photos
                    await loadExistingPhotos(currentGameIdForPhotos);
                    
                    // Update photo count in expanded card if visible
                    await loadPhotoCount(currentGameIdForPhotos);
                    
                    const successAlert = document.getElementById('photoUploadSuccess');
                    successAlert.textContent = `"${filename}" has been deleted.`;
                    successAlert.classList.remove('d-none');
                } else {
                    throw new Error(data.message || 'Failed to delete photo');
                }
            } catch (error) {
                console.error('Error deleting photo:', error);
                const errorAlert = document.getElementById('photoUploadError');
                errorAlert.textContent = 'Failed to delete photo: ' + error.message;
                errorAlert.classList.remove('d-none');
            }
        }

        // Load and display photo count for expanded cards
        async function loadPhotoCount(gameId) {
            try {
                const response = await fetch(`/api/game/${gameId}/photos`);
                const data = await response.json();
                
                if (response.ok) {
                    const photos = data.photos || [];
                    const photoCount = photos.length;
                    updatePhotoCountDisplay(gameId, photoCount);
                    updatePhotoMetadataDisplay(gameId, photos);
                } else {
                    console.error('Failed to load photo count for game', gameId, ':', data.message);
                }
            } catch (error) {
                console.error('Error loading photo count for game', gameId, ':', error);
            }
        }

        function updatePhotoCountDisplay(gameId, count) {
            const photoCountElement = document.getElementById(`photo-count-${gameId}`);
            const photoCountText = document.getElementById(`photo-count-text-${gameId}`);
            
            if (photoCountElement && photoCountText) {
                if (count > 0) {
                    photoCountText.textContent = `${count} photo${count === 1 ? '' : 's'}`;
                    photoCountElement.style.display = 'flex';
                } else {
                    photoCountElement.style.display = 'none';
                }
            }
        }

        function updatePhotoMetadataDisplay(gameId, photos) {
            const photosMetaRow = document.getElementById(`photos-meta-row-${gameId}`);
            const photosMetaCell = document.getElementById(`photos-meta-${gameId}`);
            
            if (!photosMetaRow || !photosMetaCell) return;
            
            if (photos.length === 0) {
                photosMetaRow.style.display = 'none';
                return;
            }
            
            photosMetaRow.style.display = 'table-row';
            
            photosMetaCell.innerHTML = `
                <div class="d-flex flex-column">
                    <small class="text-muted mb-1">${photos.length} photo${photos.length === 1 ? '' : 's'}</small>
                    <div style="font-size: 0.75rem;">
                        <a href="#" 
                           onclick="event.preventDefault(); openPhotoGallery(${gameId});"
                           class="text-decoration-none"
                           title="View all photos for this game">
                            📷 View Photos
                        </a>
                    </div>
                </div>
            `;
        }

        // Keyboard navigation for photo viewer
        let photoViewerKeydownHandler = null;
        
        // Add keyboard navigation when photo viewer opens
        function enablePhotoViewerKeyboard() {
            // Remove any existing handler
            if (photoViewerKeydownHandler) {
                document.removeEventListener('keydown', photoViewerKeydownHandler);
            }
            
            photoViewerKeydownHandler = function(event) {
                const modal = bootstrap.Modal.getInstance(document.getElementById('photoViewerModal'));
                if (!modal || !modal._isShown) return; // Only handle if modal is open
                
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        document.getElementById('prevPhotoBtn').click();
                        break;
                    case 'ArrowRight': 
                        event.preventDefault();
                        document.getElementById('nextPhotoBtn').click();
                        break;
                    case 'Escape':
                        event.preventDefault();
                        modal.hide();
                        break;
                }
            };
            
            document.addEventListener('keydown', photoViewerKeydownHandler);
        }
        
        // Remove keyboard navigation when photo viewer closes
        function disablePhotoViewerKeyboard() {
            if (photoViewerKeydownHandler) {
                document.removeEventListener('keydown', photoViewerKeydownHandler);
                photoViewerKeydownHandler = null;
            }
        }

        // Update photo counter display
        function updatePhotoCounter() {
            const counter = document.getElementById('photoCounter');
            if (counter && existingGamePhotos.length > 0) {
                counter.textContent = `${currentPhotoIndex + 1} / ${existingGamePhotos.length}`;
            }
        }

        // Photo gallery functions
        async function openPhotoGallery(gameId) {
            try {
                // Load photos for the game
                const response = await fetch(`/api/game/${gameId}/photos`);
                const data = await response.json();
                
                if (!response.ok || !data.photos || data.photos.length === 0) {
                    alert('No photos available for this game.');
                    return;
                }
                
                // Set up gallery state
                existingGamePhotos = data.photos;
                currentPhotoIndex = 0;
                
                // Open the first photo in the viewer
                const firstPhoto = existingGamePhotos[0];
                openPhotoViewer(firstPhoto.id, `/api/photos/${firstPhoto.id}/view`, firstPhoto.original_filename);
                
            } catch (error) {
                console.error('Error loading photo gallery:', error);
                alert('Error loading photos. Please try again.');
            }
        }

        // Barcode Scanner functionality
        let barcodeScanner = null;
        let videoStream = null;

        // Open barcode scanner modal
        document.getElementById('barcodeScannerBtn').addEventListener('click', function() {
            const modal = new bootstrap.Modal(document.getElementById('barcodeScannerModal'));
            modal.show();
            
            // Start camera when modal is shown
            document.getElementById('barcodeScannerModal').addEventListener('shown.bs.modal', startBarcodeScanner, { once: true });
        });

        // Stop scanner when modal is closed
        document.getElementById('barcodeScannerModal').addEventListener('hidden.bs.modal', stopBarcodeScanner);

        // Manual entry button
        document.getElementById('manualEntryBtn').addEventListener('click', function() {
            document.getElementById('manualEntryOption').style.display = 'block';
            this.style.display = 'none';
        });

        // Manual barcode submit
        document.getElementById('manualBarcodeSubmit').addEventListener('click', function() {
            const barcode = document.getElementById('manualBarcodeInput').value.trim();
            if (barcode) {
                handleBarcodeDetected(barcode);
            }
        });

        // Manual barcode input enter key
        document.getElementById('manualBarcodeInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('manualBarcodeSubmit').click();
            }
        });

        async function startBarcodeScanner() {
            const video = document.getElementById('barcodeVideo');
            const loadingMsg = document.getElementById('scannerLoading');
            const readyMsg = document.getElementById('scannerReady');
            const errorMsg = document.getElementById('scannerError');
            const overlay = document.getElementById('scanningOverlay');
            
            try {
                // Request camera access
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // Use back camera on mobile
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                
                video.srcObject = videoStream;
                
                // Hide loading, show ready
                loadingMsg.style.display = 'none';
                readyMsg.style.display = 'block';
                overlay.style.display = 'block';
                
                // Initialize Quagga barcode scanner
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: video,
                        constraints: {
                            width: 640,
                            height: 480,
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: [
                            "ean_reader",
                            "ean_8_reader", 
                            "code_128_reader",
                            "code_39_reader",
                            "code_93_reader",
                            "codabar_reader"
                        ]
                    }
                }, function(err) {
                    if (err) {
                        console.error('Quagga initialization error:', err);
                        showScannerError('Failed to initialize barcode scanner');
                        return;
                    }
                    
                    console.log('Quagga initialized successfully');
                    Quagga.start();
                });
                
                // Listen for barcode detection
                Quagga.onDetected(function(result) {
                    const barcode = result.codeResult.code;
                    console.log('Barcode detected:', barcode);
                    handleBarcodeDetected(barcode);
                });
                
            } catch (error) {
                console.error('Camera access error:', error);
                showScannerError('Camera access denied. Please allow camera access or use manual entry.');
                document.getElementById('manualEntryBtn').click();
            }
        }

        function stopBarcodeScanner() {
            // Stop Quagga
            if (barcodeScanner) {
                Quagga.stop();
                barcodeScanner = null;
            }
            
            // Stop video stream
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            
            // Reset UI
            document.getElementById('scannerLoading').style.display = 'block';
            document.getElementById('scannerReady').style.display = 'none';
            document.getElementById('scannerError').style.display = 'none';
            document.getElementById('scannerSuccess').style.display = 'none';
            document.getElementById('scanningOverlay').style.display = 'none';
            document.getElementById('manualEntryOption').style.display = 'none';
            document.getElementById('manualEntryBtn').style.display = 'inline-block';
            document.getElementById('manualBarcodeInput').value = '';
        }

        function showScannerError(message) {
            document.getElementById('scannerLoading').style.display = 'none';
            document.getElementById('scannerReady').style.display = 'none';
            document.getElementById('scannerError').style.display = 'block';
            document.getElementById('scannerError').textContent = message;
        }

        async function handleBarcodeDetected(barcode) {
            console.log('Processing barcode:', barcode);
            
            // Validate barcode format
            if (!isValidBarcode(barcode)) {
                showScannerError('Invalid barcode format detected');
                return;
            }
            
            // Show success message and start searching
            document.getElementById('scannerSuccess').style.display = 'block';
            document.getElementById('scannerSuccess').textContent = `Found barcode: ${barcode} - Searching games...`;
            
            try {
                // Phase 2: Search PriceCharting for games matching this barcode
                console.log('Phase 2: Searching PriceCharting for barcode:', barcode);
                
                const response = await fetch('/api/barcode/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ barcode: barcode })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Search failed');
                }
                
                // Close the scanner modal first
                bootstrap.Modal.getInstance(document.getElementById('barcodeScannerModal')).hide();
                
                // Show search results
                showBarcodeSearchResults(barcode, data.games);
                
            } catch (error) {
                console.error('Barcode search error:', error);
                showScannerError(`Search failed: ${error.message}`);
            }
        }

        function isValidBarcode(barcode) {
            // Basic validation for common barcode formats
            const cleaned = barcode.replace(/\D/g, ''); // Remove non-digits
            
            // UPC-A: 12 digits
            // UPC-E: 8 digits
            // EAN-13: 13 digits
            // EAN-8: 8 digits
            const validLengths = [8, 12, 13];
            
            return validLengths.includes(cleaned.length) && cleaned.length > 0;
        }

        function showBarcodeSearchResults(barcode, games) {
            console.log('Showing barcode search results:', { barcode, games });
            
            const modal = document.getElementById('barcodeResultsModal');
            const content = document.getElementById('barcodeResultsContent');
            const title = document.getElementById('barcodeResultsModalLabel');
            
            // Update modal title
            title.textContent = `🎮 Results for Barcode: ${barcode}`;
            
            if (!games || games.length === 0) {
                content.innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-search fa-3x mb-3"></i>
                        <h5>No games found</h5>
                        <p>No games were found for barcode <strong>${barcode}</strong>.</p>
                        <p class="small">Try scanning a different barcode or add the game manually using the search bar.</p>
                    </div>
                `;
            } else {
                // Create HTML for search results
                const resultsHtml = games.map(game => `
                    <div class="border rounded p-3 mb-3 game-result-item" style="cursor: pointer; transition: background-color 0.2s;"
                         onmouseover="this.style.backgroundColor='#f8f9fa'" 
                         onmouseout="this.style.backgroundColor=''" 
                         onclick="selectGameFromBarcode('${game.url.replace(/'/g, "\\'")}', '${game.name.replace(/'/g, "\\'")}', '${game.console.replace(/'/g, "\\'")}')">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <h6 class="mb-1">${game.name}</h6>
                                <span class="badge bg-secondary">${game.console}</span>
                            </div>
                            <div class="text-end">
                                <small class="text-muted">Click to add</small>
                                <div><i class="fas fa-plus-circle text-primary"></i></div>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                content.innerHTML = `
                    <div class="mb-3">
                        <p class="text-muted">Found <strong>${games.length}</strong> game${games.length !== 1 ? 's' : ''} for barcode <strong>${barcode}</strong>. Click on a game to add it to your collection:</p>
                    </div>
                    ${resultsHtml}
                `;
            }
            
            // Show the modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }

        function selectGameFromBarcode(priceChartingUrl, gameName, gameConsole) {
            console.log('Selected game from barcode search:', { priceChartingUrl, gameName, gameConsole });
            
            // Close the results modal
            const resultsModal = bootstrap.Modal.getInstance(document.getElementById('barcodeResultsModal'));
            resultsModal.hide();
            
            // Pre-populate the add game form with the PriceCharting URL
            const urlField = document.getElementById('pricechartingUrl');
            if (urlField) {
                urlField.value = priceChartingUrl;
            } else {
                console.error('Could not find pricechartingUrl field');
                return;
            }
            
            // Show the add game modal (wishlistModal is the add game modal)
            const addModal = document.getElementById('wishlistModal');
            if (addModal) {
                const bootstrapModal = new bootstrap.Modal(addModal);
                bootstrapModal.show();
            } else {
                console.error('Could not find wishlistModal');
                return;
            }
            
            // Show success toast
            window.errorHandler.showSuccessToast(`Game "${gameName}" selected from barcode! Fill in remaining details and add to collection.`);
        }

    </script>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register("{{ url_for('static', filename='js/service-worker.js') }}")
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>
</html>
