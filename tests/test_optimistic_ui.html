<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimistic UI Test Suite</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass { background: #d4edda; color: #155724; }
        .test-fail { background: #f8d7da; color: #721c24; }
        .test-pending { background: #fff3cd; color: #856404; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        #testResults { margin-top: 20px; }
        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .stat {
            padding: 10px;
            background: white;
            border-radius: 4px;
            flex: 1;
            text-align: center;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Optimistic UI Test Suite</h1>
    
    <div class="test-section">
        <h2>Test Controls</h2>
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="runUnitTests()">Run Unit Tests</button>
        <button onclick="runIntegrationTests()">Run Integration Tests</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="test-section">
        <h2>Test Statistics</h2>
        <div class="stats">
            <div class="stat">
                <h3 id="totalTests">0</h3>
                <p>Total Tests</p>
            </div>
            <div class="stat">
                <h3 id="passedTests" style="color: green;">0</h3>
                <p>Passed</p>
            </div>
            <div class="stat">
                <h3 id="failedTests" style="color: red;">0</h3>
                <p>Failed</p>
            </div>
            <div class="stat">
                <h3 id="pendingTests" style="color: orange;">0</h3>
                <p>Pending</p>
            </div>
        </div>
    </div>

    <div class="test-section">
        <h2>Test Results</h2>
        <div id="testResults"></div>
    </div>

    <!-- Mock DOM elements for testing -->
    <div style="display: none;">
        <table id="collectionTable">
            <tbody></tbody>
        </table>
        <div id="resultCount"></div>
        <div id="removeWishlistModal" data-game-id="" data-game-name="" data-game-console=""></div>
        <div id="removeFromCollectionModal" data-game-id="" data-game-name="" data-game-console="" data-purchased-game-id=""></div>
    </div>

    <!-- Load dependencies -->
    <script src="../app/static/js/state-manager.js"></script>
    <script src="../app/static/js/error-handler.js"></script>
    <script src="../app/static/js/optimistic-updater.js"></script>
    <script src="../app/static/js/main.js"></script>

    <script>
        // Test framework
        class TestRunner {
            constructor() {
                this.results = [];
                this.stats = { total: 0, passed: 0, failed: 0, pending: 0 };
            }

            async runTest(name, testFn) {
                this.stats.total++;
                const result = { name, status: 'pending', error: null, time: 0 };
                
                try {
                    const startTime = performance.now();
                    await testFn();
                    result.time = performance.now() - startTime;
                    result.status = 'pass';
                    this.stats.passed++;
                } catch (error) {
                    result.status = 'fail';
                    result.error = error.message || error;
                    this.stats.failed++;
                }
                
                this.results.push(result);
                this.renderResult(result);
                this.updateStats();
                return result;
            }

            renderResult(result) {
                const resultsDiv = document.getElementById('testResults');
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result test-${result.status}`;
                
                let content = `<strong>${result.name}</strong> - ${result.status.toUpperCase()}`;
                if (result.time) {
                    content += ` (${result.time.toFixed(2)}ms)`;
                }
                if (result.error) {
                    content += `<br><pre>${result.error}</pre>`;
                }
                
                resultDiv.innerHTML = content;
                resultsDiv.appendChild(resultDiv);
            }

            updateStats() {
                document.getElementById('totalTests').textContent = this.stats.total;
                document.getElementById('passedTests').textContent = this.stats.passed;
                document.getElementById('failedTests').textContent = this.stats.failed;
                document.getElementById('pendingTests').textContent = this.stats.pending;
            }

            clear() {
                this.results = [];
                this.stats = { total: 0, passed: 0, failed: 0, pending: 0 };
                document.getElementById('testResults').innerHTML = '';
                this.updateStats();
            }
        }

        const testRunner = new TestRunner();

        // Assertion helpers
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        function assertNotNull(value, message) {
            if (value === null || value === undefined) {
                throw new Error(message || 'Value is null or undefined');
            }
        }

        // Mock fetch for testing
        let fetchMock = null;
        const originalFetch = window.fetch;

        function mockFetch(responseMap) {
            fetchMock = responseMap;
            window.fetch = async (url, options) => {
                const key = `${options?.method || 'GET'} ${url}`;
                const mockResponse = fetchMock[key];
                
                if (mockResponse) {
                    return {
                        ok: mockResponse.ok !== false,
                        status: mockResponse.status || 200,
                        json: async () => mockResponse.data,
                        text: async () => JSON.stringify(mockResponse.data)
                    };
                }
                
                return originalFetch(url, options);
            };
        }

        function restoreFetch() {
            window.fetch = originalFetch;
            fetchMock = null;
        }

        // Unit Tests
        async function runUnitTests() {
            console.log('Running Unit Tests...');
            
            // Test GameStateManager
            await testRunner.runTest('GameStateManager: Add and retrieve game', () => {
                const game = { id: 1, name: 'Test Game', console: 'N64' };
                window.gameStateManager.addGame(game);
                const retrieved = window.gameStateManager.getGame(1);
                assertEqual(retrieved.name, 'Test Game');
                window.gameStateManager.removeGame(1);
            });

            await testRunner.runTest('GameStateManager: Update existing game', () => {
                const game = { id: 2, name: 'Original', console: 'N64' };
                window.gameStateManager.addGame(game);
                
                const updated = { id: 2, name: 'Updated', console: 'N64' };
                window.gameStateManager.updateGame(updated);
                
                const retrieved = window.gameStateManager.getGame(2);
                assertEqual(retrieved.name, 'Updated');
                window.gameStateManager.removeGame(2);
            });

            await testRunner.runTest('GameStateManager: Remove game', () => {
                const game = { id: 3, name: 'To Remove', console: 'N64' };
                window.gameStateManager.addGame(game);
                
                const removed = window.gameStateManager.removeGame(3);
                assert(removed, 'Game should be removed');
                
                const retrieved = window.gameStateManager.getGame(3);
                assert(retrieved === null, 'Game should not exist after removal');
            });

            await testRunner.runTest('GameStateManager: Pending operations', () => {
                window.gameStateManager.setPendingOperation(4, 'test_op', { test: true });
                const pending = window.gameStateManager.getPendingOperation(4);
                
                assertNotNull(pending);
                assertEqual(pending.operation, 'test_op');
                
                window.gameStateManager.clearPendingOperation(4);
                const cleared = window.gameStateManager.getPendingOperation(4);
                assert(cleared === null, 'Pending operation should be cleared');
            });

            // Test OptimisticUpdater
            await testRunner.runTest('OptimisticUpdater: Has required methods', () => {
                assert(typeof window.optimisticUpdater.applyOptimisticUpdate === 'function');
                assert(typeof window.optimisticUpdater.confirmUpdate === 'function');
                assert(typeof window.optimisticUpdater.rollbackUpdate === 'function');
            });

            // Test main.js functions
            await testRunner.runTest('Main.js: createGameRow creates valid element', () => {
                const game = {
                    id: 5,
                    name: 'Mario Kart 64',
                    console: 'Nintendo 64',
                    current_price: 39.99
                };
                
                const row = window.createGameRow(game, false);
                assert(row instanceof HTMLElement, 'Should return HTML element');
                assertEqual(row.dataset.gameId, '5');
                assert(row.querySelector('.game-name').textContent === 'Mario Kart 64');
            });

            await testRunner.runTest('Main.js: updateResultCount modifies display', () => {
                const resultCount = document.getElementById('resultCount');
                resultCount.innerHTML = 'Showing 1-10 of 20 results';
                
                window.updateResultCount(1);
                assert(resultCount.innerHTML.includes('21'), 'Should increment total');
            });
        }

        // Integration Tests
        async function runIntegrationTests() {
            console.log('Running Integration Tests...');
            
            // Test Add to Wishlist Optimistic
            await testRunner.runTest('Add to Wishlist: Optimistic update succeeds', async () => {
                mockFetch({
                    'POST /api/wishlist/add': {
                        ok: true,
                        data: {
                            game: {
                                id: 100,
                                name: 'GoldenEye 007',
                                console: 'N64',
                                current_price: 29.99
                            }
                        }
                    }
                });

                const gameData = {
                    url: 'https://www.pricecharting.com/game/nintendo-64/goldeneye-007',
                    condition: 'CIB'
                };

                await window.addToWishlistOptimistic(gameData);
                
                // Check that game was added to state
                const game = window.gameStateManager.getGame(100);
                assertNotNull(game, 'Game should be in state manager');
                assertEqual(game.name, 'GoldenEye 007');
                
                // Cleanup
                window.gameStateManager.removeGame(100);
                restoreFetch();
            });

            await testRunner.runTest('Add to Wishlist: Rollback on failure', async () => {
                mockFetch({
                    'POST /api/wishlist/add': {
                        ok: false,
                        status: 500,
                        data: { error: 'Server error' }
                    }
                });

                const gameData = {
                    url: 'https://www.pricecharting.com/game/nintendo-64/perfect-dark',
                    condition: 'CIB'
                };

                try {
                    await window.addToWishlistOptimistic(gameData);
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that temporary game was removed
                const games = window.gameStateManager.getAllGames();
                const tempGame = games.find(g => g.id && g.id.toString().startsWith('temp_'));
                assert(!tempGame, 'Temporary game should be rolled back');
                
                restoreFetch();
            });

            // Test Remove from Wishlist Optimistic
            await testRunner.runTest('Remove from Wishlist: Optimistic update succeeds', async () => {
                // First add a game to state
                const game = { id: 200, name: 'Banjo-Kazooie', console: 'N64' };
                window.gameStateManager.addGame(game);
                
                mockFetch({
                    'DELETE /api/wishlist/200/remove': {
                        ok: true,
                        data: { message: 'Game removed' }
                    }
                });

                await window.removeFromWishlistOptimistic(200, 'Banjo-Kazooie', 'N64');
                
                // Check that game was removed from state
                const removed = window.gameStateManager.getGame(200);
                assert(removed === null, 'Game should be removed from state');
                
                restoreFetch();
            });

            await testRunner.runTest('Remove from Wishlist: Rollback on failure', async () => {
                // Add a game to state
                const game = { id: 201, name: 'Star Fox 64', console: 'N64' };
                window.gameStateManager.addGame(game);
                
                mockFetch({
                    'DELETE /api/wishlist/201/remove': {
                        ok: false,
                        status: 404,
                        data: { error: 'Game not found' }
                    }
                });

                try {
                    await window.removeFromWishlistOptimistic(201, 'Star Fox 64', 'N64');
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that game was restored to state
                const restored = window.gameStateManager.getGame(201);
                assertNotNull(restored, 'Game should be restored to state');
                assertEqual(restored.name, 'Star Fox 64');
                
                // Cleanup
                window.gameStateManager.removeGame(201);
                restoreFetch();
            });

            // Test Purchase Conversion Optimistic
            await testRunner.runTest('Purchase Conversion: Optimistic update succeeds', async () => {
                // First add a game to wishlist state
                const wishlistGame = { id: 250, name: 'Paper Mario', console: 'N64', is_wanted: true, current_price: 89.99 };
                window.gameStateManager.addGame(wishlistGame);
                
                mockFetch({
                    'POST /api/wishlist/250/purchase': {
                        ok: true,
                        data: {
                            message: 'Successfully purchased Paper Mario!',
                            game: {
                                id: 250,
                                purchased_game_id: 350,
                                name: 'Paper Mario',
                                console: 'N64',
                                purchase_date: '2024-01-15',
                                purchase_source: 'Local Store',
                                purchase_price: 79.99
                            }
                        }
                    }
                });

                const purchaseData = {
                    purchase_date: '2024-01-15',
                    purchase_source: 'Local Store',
                    purchase_price: '79.99'
                };

                await window.purchaseWishlistGameOptimistic(250, 'Paper Mario', 'N64', purchaseData);
                
                // Check that game was converted in state (from wishlist to collection)
                const convertedGame = window.gameStateManager.getGame(250);
                assertNotNull(convertedGame, 'Game should be in state manager');
                assertEqual(convertedGame.name, 'Paper Mario');
                assertEqual(convertedGame.is_wanted, false);
                assertEqual(convertedGame.purchase_price, 79.99);
                
                // Cleanup
                window.gameStateManager.removeGame(250);
                restoreFetch();
            });

            await testRunner.runTest('Purchase Conversion: Rollback on failure', async () => {
                // Add a wishlist game to state
                const wishlistGame = { id: 260, name: 'Mario Party 3', console: 'N64', is_wanted: true };
                window.gameStateManager.addGame(wishlistGame);
                
                mockFetch({
                    'POST /api/wishlist/260/purchase': {
                        ok: false,
                        status: 400,
                        data: { error: 'Purchase date is required' }
                    }
                });

                const purchaseData = {
                    purchase_source: 'Online'
                    // Missing purchase_date
                };

                try {
                    await window.purchaseWishlistGameOptimistic(260, 'Mario Party 3', 'N64', purchaseData);
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that game was restored to wishlist state
                const restoredGame = window.gameStateManager.getGame(260);
                assertNotNull(restoredGame, 'Game should be restored to state');
                assertEqual(restoredGame.name, 'Mario Party 3');
                assertEqual(restoredGame.is_wanted, true);
                
                // Cleanup
                window.gameStateManager.removeGame(260);
                restoreFetch();
            });

            // Test Add to Collection Optimistic
            await testRunner.runTest('Add to Collection: Optimistic update succeeds', async () => {
                mockFetch({
                    'POST /api/collection/add': {
                        ok: true,
                        data: {
                            game: {
                                id: 300,
                                purchased_game_id: 300,
                                name: 'Mario Party',
                                console: 'N64',
                                purchase_price: 44.99,
                                current_price: 54.99
                            }
                        }
                    }
                });

                const gameData = {
                    url: 'https://www.pricecharting.com/game/nintendo-64/mario-party',
                    condition: 'CIB',
                    purchase_price: 44.99,
                    purchase_date: '2024-01-01'
                };

                await window.addToCollectionOptimistic(gameData);
                
                // Check that game was added to state
                const game = window.gameStateManager.getGame(300);
                assertNotNull(game, 'Game should be in state manager');
                assertEqual(game.name, 'Mario Party');
                assertEqual(game.purchase_price, 44.99);
                
                // Cleanup
                window.gameStateManager.removeGame(300);
                restoreFetch();
            });

            // Test Mark as Lent Optimistic
            await testRunner.runTest('Mark as Lent: Optimistic update succeeds', async () => {
                // Add a collection game to state
                const collectionGame = { id: 270, name: 'Mario Party 2', console: 'N64', is_wanted: false, is_lent: false };
                window.gameStateManager.addGame(collectionGame);
                
                mockFetch({
                    'POST /api/game/270/mark_as_lent': {
                        ok: true,
                        data: { message: 'Game marked as lent out successfully!' }
                    }
                });

                const lentData = {
                    lent_date: '2024-02-01',
                    lent_to: 'Friend Name'
                };

                await window.markGameAsLentOptimistic(270, 'Mario Party 2', 'N64', lentData);
                
                // Check that game was marked as lent in state
                const lentGame = window.gameStateManager.getGame(270);
                assertNotNull(lentGame, 'Game should be in state manager');
                assertEqual(lentGame.name, 'Mario Party 2');
                assertEqual(lentGame.is_lent, true);
                assertEqual(lentGame.lent_to, 'Friend Name');
                assertEqual(lentGame.lent_date, '2024-02-01');
                
                // Cleanup
                window.gameStateManager.removeGame(270);
                restoreFetch();
            });

            await testRunner.runTest('Mark as Lent: Rollback on failure', async () => {
                // Add a collection game to state
                const collectionGame = { id: 280, name: 'Super Mario 64', console: 'N64', is_wanted: false, is_lent: false };
                window.gameStateManager.addGame(collectionGame);
                
                mockFetch({
                    'POST /api/game/280/mark_as_lent': {
                        ok: false,
                        status: 400,
                        data: { error: 'Lent date is required' }
                    }
                });

                const lentData = {
                    lent_to: 'Someone'
                    // Missing lent_date
                };

                try {
                    await window.markGameAsLentOptimistic(280, 'Super Mario 64', 'N64', lentData);
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that game was restored to original state
                const restoredGame = window.gameStateManager.getGame(280);
                assertNotNull(restoredGame, 'Game should be restored to state');
                assertEqual(restoredGame.name, 'Super Mario 64');
                assertEqual(restoredGame.is_lent, false);
                
                // Cleanup
                window.gameStateManager.removeGame(280);
                restoreFetch();
            });

            // Test Return from Lent Optimistic
            await testRunner.runTest('Return from Lent: Optimistic update succeeds', async () => {
                // Add a lent game to state
                const lentGame = { 
                    id: 290, 
                    name: 'GoldenEye 007', 
                    console: 'N64', 
                    is_wanted: false, 
                    is_lent: true,
                    lent_to: 'Test Person',
                    lent_date: '2024-01-15'
                };
                window.gameStateManager.addGame(lentGame);
                
                mockFetch({
                    'DELETE /api/game/290/unmark_as_lent': {
                        ok: true,
                        data: { message: 'Game marked as returned successfully!' }
                    }
                });

                await window.unmarkGameAsLentOptimistic(290, 'GoldenEye 007', 'N64');
                
                // Check that game was marked as returned in state
                const returnedGame = window.gameStateManager.getGame(290);
                assertNotNull(returnedGame, 'Game should be in state manager');
                assertEqual(returnedGame.name, 'GoldenEye 007');
                assertEqual(returnedGame.is_lent, false);
                assertEqual(returnedGame.lent_to, null);
                assertEqual(returnedGame.lent_date, null);
                
                // Cleanup
                window.gameStateManager.removeGame(290);
                restoreFetch();
            });

            await testRunner.runTest('Return from Lent: Rollback on failure', async () => {
                // Add a lent game to state
                const lentGame = { 
                    id: 300, 
                    name: 'Perfect Dark', 
                    console: 'N64', 
                    is_wanted: false, 
                    is_lent: true,
                    lent_to: 'Friend',
                    lent_date: '2024-01-20'
                };
                window.gameStateManager.addGame(lentGame);
                
                mockFetch({
                    'DELETE /api/game/300/unmark_as_lent': {
                        ok: false,
                        status: 404,
                        data: { error: 'Game not found or not lent out' }
                    }
                });

                try {
                    await window.unmarkGameAsLentOptimistic(300, 'Perfect Dark', 'N64');
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that game was restored to lent state
                const restoredGame = window.gameStateManager.getGame(300);
                assertNotNull(restoredGame, 'Game should be restored to state');
                assertEqual(restoredGame.name, 'Perfect Dark');
                assertEqual(restoredGame.is_lent, true);
                assertEqual(restoredGame.lent_to, 'Friend');
                
                // Cleanup
                window.gameStateManager.removeGame(300);
                restoreFetch();
            });

            // Test Remove from Collection Optimistic
            await testRunner.runTest('Remove from Collection: Optimistic update succeeds', async () => {
                // First add a game to state
                const game = {
                    id: 400,
                    purchased_game_id: 400,
                    name: 'Donkey Kong 64',
                    console: 'N64',
                    purchase_price: 19.99
                };
                window.gameStateManager.addGame(game);
                
                mockFetch({
                    'DELETE /api/purchased_game/400/remove_from_collection': {
                        ok: true,
                        data: { message: 'Game removed from collection' }
                    }
                });

                await window.removeFromCollectionOptimistic(400, 400, 'Donkey Kong 64', 'N64');
                
                // Check that game was removed from state
                const removed = window.gameStateManager.getGame(400);
                assert(removed === null, 'Game should be removed from state');
                
                restoreFetch();
            });

            // Test Edit Game Details Optimistic
            await testRunner.runTest('Edit Game Details: Optimistic update succeeds', async () => {
                // Add a game to state first
                const originalGame = { 
                    id: 500, 
                    name: 'Original Game Name', 
                    console: 'Original Console',
                    is_wanted: false 
                };
                window.gameStateManager.addGame(originalGame);
                
                mockFetch({
                    'PUT /api/game/500/details': {
                        ok: true,
                        data: { 
                            message: 'Game details updated successfully',
                            name: 'Updated Game Name',
                            console: 'Updated Console'
                        }
                    }
                });

                await window.editGameDetailsOptimistic(500, 'Updated Game Name', 'Updated Console');
                
                // Check that game details were updated in state
                const updatedGame = window.gameStateManager.getGame(500);
                assertNotNull(updatedGame, 'Game should still be in state manager');
                assertEqual(updatedGame.name, 'Updated Game Name');
                assertEqual(updatedGame.console, 'Updated Console');
                
                // Cleanup
                window.gameStateManager.removeGame(500);
                restoreFetch();
            });

            await testRunner.runTest('Edit Game Details: Rollback on failure', async () => {
                // Add a game to state first
                const originalGame = { 
                    id: 510, 
                    name: 'Original Game Name', 
                    console: 'Original Console',
                    is_wanted: false 
                };
                window.gameStateManager.addGame(originalGame);
                
                mockFetch({
                    'PUT /api/game/510/details': {
                        ok: false,
                        status: 400,
                        data: { error: 'Game name is required' }
                    }
                });

                try {
                    await window.editGameDetailsOptimistic(510, '', 'Some Console');
                    throw new Error('Should have thrown error');
                } catch (error) {
                    // Expected to fail
                }
                
                // Check that game details were restored to original values
                const restoredGame = window.gameStateManager.getGame(510);
                assertNotNull(restoredGame, 'Game should still be in state manager');
                assertEqual(restoredGame.name, 'Original Game Name');
                assertEqual(restoredGame.console, 'Original Console');
                
                // Cleanup
                window.gameStateManager.removeGame(510);
                restoreFetch();
            });

            await testRunner.runTest('Edit Game Details: Handles missing game in state', async () => {
                try {
                    await window.editGameDetailsOptimistic(999, 'New Name', 'New Console');
                    throw new Error('Should have thrown error');
                } catch (error) {
                    assert(error.message.includes('not found in state manager'), 
                           'Should throw appropriate error for missing game');
                }
            });

            await testRunner.runTest('Edit Game Details: Updates all UI locations', async () => {
                // Add a game to state
                const originalGame = { 
                    id: 520, 
                    name: 'Test Game', 
                    console: 'Test Console',
                    is_wanted: false 
                };
                window.gameStateManager.addGame(originalGame);
                
                // Create mock DOM elements
                const tableRow = document.createElement('tr');
                tableRow.className = 'game-row';
                tableRow.dataset.gameId = '520';
                
                const nameCell = document.createElement('td');
                nameCell.className = 'name-col';
                nameCell.textContent = 'Test Game';
                nameCell.title = 'Test Game';
                
                const consoleCell = document.createElement('td');
                consoleCell.className = 'console-col';
                consoleCell.textContent = 'Test Console';
                consoleCell.title = 'Test Console';
                
                tableRow.appendChild(nameCell);
                tableRow.appendChild(consoleCell);
                document.body.appendChild(tableRow);
                
                mockFetch({
                    'PUT /api/game/520/details': {
                        ok: true,
                        data: { 
                            message: 'Game details updated successfully',
                            name: 'Updated Test Game',
                            console: 'Updated Test Console'
                        }
                    }
                });

                await window.editGameDetailsOptimistic(520, 'Updated Test Game', 'Updated Test Console');
                
                // Check that DOM elements were updated
                assertEqual(nameCell.textContent, 'Updated Test Game');
                assertEqual(nameCell.title, 'Updated Test Game');
                assertEqual(consoleCell.textContent, 'Updated Test Console');
                assertEqual(consoleCell.title, 'Updated Test Console');
                
                // Cleanup
                document.body.removeChild(tableRow);
                window.gameStateManager.removeGame(520);
                restoreFetch();
            });

            // Phase 3: Selective Refresh Tests
            await testRunner.runTest('Selective Refresh: refreshGame() succeeds', async () => {
                // Add a game to state
                const originalGame = { 
                    id: 600, 
                    name: 'Original Name', 
                    console: 'Original Console',
                    is_wanted: false,
                    purchase_price: 29.99
                };
                window.gameStateManager.addGame(originalGame);
                
                // Mock the single game API endpoint
                mockFetch({
                    'GET /api/game/600': {
                        ok: true,
                        data: { 
                            game: {
                                id: 600,
                                name: 'Updated Name',
                                console: 'Updated Console', 
                                is_wanted: false,
                                purchase_price: 39.99,
                                current_price: 45.99
                            }
                        }
                    }
                });

                const result = await window.refreshGame(600);
                
                // Check that game was updated in state
                const updatedGame = window.gameStateManager.getGame(600);
                assertNotNull(updatedGame, 'Game should still be in state manager');
                assertEqual(updatedGame.name, 'Updated Name');
                assertEqual(updatedGame.console, 'Updated Console');
                assertEqual(updatedGame.purchase_price, 39.99);
                assertEqual(updatedGame.current_price, 45.99);
                
                // Cleanup
                window.gameStateManager.removeGame(600);
                restoreFetch();
            });

            await testRunner.runTest('Selective Refresh: handles 404 (deleted game)', async () => {
                // Add a game to state
                const originalGame = { id: 610, name: 'To Be Deleted', console: 'N64' };
                window.gameStateManager.addGame(originalGame);
                
                // Mock 404 response (game was deleted)
                mockFetch({
                    'GET /api/game/610': {
                        ok: false,
                        status: 404,
                        data: { error: 'Game not found' }
                    }
                });

                const result = await window.refreshGame(610);
                
                // Check that game was removed from state
                const deletedGame = window.gameStateManager.getGame(610);
                assert(deletedGame === null, 'Deleted game should be removed from state');
                assert(result === null, 'Function should return null for deleted games');
                
                restoreFetch();
            });

            await testRunner.runTest('Selective Refresh: no changes detected', async () => {
                // Add a game to state
                const gameData = { 
                    id: 620, 
                    name: 'Unchanged Game', 
                    console: 'N64',
                    is_wanted: false,
                    purchase_price: 24.99
                };
                window.gameStateManager.addGame(gameData);
                
                // Mock API returning exactly same data
                mockFetch({
                    'GET /api/game/620': {
                        ok: true,
                        data: { game: gameData }
                    }
                });

                const result = await window.refreshGame(620);
                
                // Should return current data unchanged
                assertNotNull(result, 'Should return game data');
                assertEqual(result.name, 'Unchanged Game');
                assertEqual(result.purchase_price, 24.99);
                
                // State should remain the same
                const unchangedGame = window.gameStateManager.getGame(620);
                assertEqual(unchangedGame.name, 'Unchanged Game');
                
                // Cleanup
                window.gameStateManager.removeGame(620);
                restoreFetch();
            });

            await testRunner.runTest('Selective Refresh: differential DOM update', async () => {
                // Add a game to state
                const originalGame = { 
                    id: 630, 
                    name: 'DOM Test Game', 
                    console: 'GameCube',
                    condition: 'complete'
                };
                window.gameStateManager.addGame(originalGame);
                
                // Create mock DOM elements
                const tableRow = document.createElement('tr');
                tableRow.className = 'game-row';
                tableRow.dataset.gameId = '630';
                
                const nameCell = document.createElement('td');
                nameCell.className = 'name-col';
                nameCell.textContent = 'DOM Test Game';
                nameCell.title = 'DOM Test Game';
                
                const consoleCell = document.createElement('td');
                consoleCell.className = 'console-col';
                consoleCell.textContent = 'GameCube';
                consoleCell.title = 'GameCube';
                
                tableRow.appendChild(nameCell);
                tableRow.appendChild(consoleCell);
                document.body.appendChild(tableRow);
                
                // Mock API returning updated data (only name changed)
                mockFetch({
                    'GET /api/game/630': {
                        ok: true,
                        data: { 
                            game: {
                                id: 630,
                                name: 'Updated DOM Game', // Changed
                                console: 'GameCube', // Unchanged
                                condition: 'complete'
                            }
                        }
                    }
                });

                await window.refreshGame(630);
                
                // Check that only changed elements were updated
                assertEqual(nameCell.textContent, 'Updated DOM Game');
                assertEqual(nameCell.title, 'Updated DOM Game');
                assertEqual(consoleCell.textContent, 'GameCube'); // Should remain unchanged
                
                // Cleanup
                document.body.removeChild(tableRow);
                window.gameStateManager.removeGame(630);
                restoreFetch();
            });

            await testRunner.runTest('Selective Refresh: network error handling', async () => {
                // Add a game to state
                const originalGame = { id: 640, name: 'Network Test', console: 'PS2' };
                window.gameStateManager.addGame(originalGame);
                
                // Mock network error
                mockFetch({
                    'GET /api/game/640': {
                        ok: false,
                        status: 500,
                        data: { error: 'Internal server error' }
                    }
                });

                const result = await window.refreshGame(640);
                
                // Should return null on error but leave state unchanged
                assert(result === null, 'Should return null on error');
                
                const unchangedGame = window.gameStateManager.getGame(640);
                assertNotNull(unchangedGame, 'Original game should remain in state');
                assertEqual(unchangedGame.name, 'Network Test');
                
                // Cleanup
                window.gameStateManager.removeGame(640);
                restoreFetch();
            });

            // Phase 3.2: Batch Refresh Tests
            await testRunner.runTest('Batch Refresh: refreshMultipleGames() immediate mode', async () => {
                // Add games to state
                const games = [
                    { id: 700, name: 'Batch Game 1', console: 'N64', purchase_price: 29.99 },
                    { id: 701, name: 'Batch Game 2', console: 'GameCube', purchase_price: 34.99 },
                    { id: 702, name: 'Batch Game 3', console: 'PS2', purchase_price: 19.99 }
                ];
                games.forEach(game => window.gameStateManager.addGame(game));
                
                // Mock batch API response
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: true,
                        data: {
                            games: [
                                { id: 700, name: 'Updated Batch Game 1', console: 'N64', purchase_price: 39.99, current_price: 45.99 },
                                { id: 701, name: 'Batch Game 2', console: 'GameCube', purchase_price: 34.99, current_price: 40.99 },
                                { id: 702, name: 'Updated Batch Game 3', console: 'PlayStation 2', purchase_price: 24.99, current_price: 29.99 }
                            ],
                            missing_game_ids: [],
                            found_count: 3,
                            missing_count: 0
                        }
                    }
                });

                const results = await window.refreshMultipleGames([700, 701, 702], { immediate: true });
                
                // Verify results structure
                assert(Array.isArray(results), 'Should return array of results');
                assertEqual(results.length, 3);
                
                // Verify games were updated in state
                const updatedGame1 = window.gameStateManager.getGame(700);
                assertEqual(updatedGame1.name, 'Updated Batch Game 1');
                assertEqual(updatedGame1.current_price, 45.99);
                
                const updatedGame2 = window.gameStateManager.getGame(701);
                assertEqual(updatedGame2.name, 'Batch Game 2'); // Unchanged
                assertEqual(updatedGame2.current_price, 40.99); // New field
                
                const updatedGame3 = window.gameStateManager.getGame(702);
                assertEqual(updatedGame3.console, 'PlayStation 2'); // Updated
                assertEqual(updatedGame3.purchase_price, 24.99); // Updated
                
                // Cleanup
                games.forEach(game => window.gameStateManager.removeGame(game.id));
                restoreFetch();
            });

            await testRunner.runTest('Batch Refresh: handles missing games', async () => {
                // Add one game to state
                const existingGame = { id: 710, name: 'Existing Game', console: 'N64' };
                window.gameStateManager.addGame(existingGame);
                
                // Mock batch API response with missing games
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: true,
                        data: {
                            games: [
                                { id: 710, name: 'Existing Game', console: 'N64', purchase_price: 29.99 }
                            ],
                            missing_game_ids: [711, 712],
                            found_count: 1,
                            missing_count: 2
                        }
                    }
                });

                const results = await window.refreshMultipleGames([710, 711, 712], { immediate: true });
                
                // Verify results
                assertEqual(results.length, 3);
                
                // Check existing game result
                const existingResult = results.find(r => r.gameId === 710);
                assert(existingResult.status === 'unchanged' || existingResult.status === 'updated');
                
                // Check deleted game results
                const deletedResults = results.filter(r => r.status === 'deleted');
                assertEqual(deletedResults.length, 2);
                
                // Verify games were removed from state
                const deletedGame1 = window.gameStateManager.getGame(711);
                assert(deletedGame1 === null, 'Deleted game should be removed from state');
                
                // Cleanup
                window.gameStateManager.removeGame(710);
                restoreFetch();
            });

            await testRunner.runTest('Batch Refresh: debouncing works correctly', async () => {
                // Add games to state
                const games = [
                    { id: 720, name: 'Debounce Game 1', console: 'N64' },
                    { id: 721, name: 'Debounce Game 2', console: 'GameCube' }
                ];
                games.forEach(game => window.gameStateManager.addGame(game));
                
                // Mock batch API response
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: true,
                        data: {
                            games: [
                                { id: 720, name: 'Debounce Game 1', console: 'N64', current_price: 35.99 },
                                { id: 721, name: 'Debounce Game 2', console: 'GameCube', current_price: 40.99 }
                            ],
                            missing_game_ids: [],
                            found_count: 2,
                            missing_count: 0
                        }
                    }
                });

                // Make multiple rapid calls (should be debounced into one batch)
                const promise1 = window.refreshMultipleGames([720]);
                const promise2 = window.refreshMultipleGames([721]);
                const promise3 = window.refreshMultipleGames([720, 721]);
                
                // Wait for debounced execution
                const [results1, results2, results3] = await Promise.all([promise1, promise2, promise3]);
                
                // All should have the same results (debounced into single batch)
                assert(Array.isArray(results1), 'Should return array results');
                assert(Array.isArray(results2), 'Should return array results');
                assert(Array.isArray(results3), 'Should return array results');
                
                // Cleanup
                games.forEach(game => window.gameStateManager.removeGame(game.id));
                restoreFetch();
            });

            await testRunner.runTest('Batch Refresh: queueGameRefresh convenience function', async () => {
                // Add game to state
                const game = { id: 730, name: 'Queue Test Game', console: 'PS1' };
                window.gameStateManager.addGame(game);
                
                // Mock batch API response
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: true,
                        data: {
                            games: [
                                { id: 730, name: 'Queue Test Game', console: 'PS1', current_price: 25.99 }
                            ],
                            missing_game_ids: [],
                            found_count: 1,
                            missing_count: 0
                        }
                    }
                });

                const results = await window.queueGameRefresh(730);
                
                assert(Array.isArray(results), 'Should return array results');
                
                // Verify game was updated
                const updatedGame = window.gameStateManager.getGame(730);
                assertEqual(updatedGame.current_price, 25.99);
                
                // Cleanup
                window.gameStateManager.removeGame(730);
                restoreFetch();
            });

            await testRunner.runTest('Batch Refresh: network error handling', async () => {
                // Add games to state
                const games = [
                    { id: 740, name: 'Error Game 1', console: 'N64' },
                    { id: 741, name: 'Error Game 2', console: 'GameCube' }
                ];
                games.forEach(game => window.gameStateManager.addGame(game));
                
                // Mock network error
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: false,
                        status: 500,
                        data: { error: 'Internal server error' }
                    }
                });

                const results = await window.refreshMultipleGames([740, 741], { immediate: true });
                
                // Should return empty array on error but not break
                assert(Array.isArray(results), 'Should return array even on error');
                assertEqual(results.length, 0, 'Should return empty array on error');
                
                // Original games should remain in state unchanged
                const game1 = window.gameStateManager.getGame(740);
                const game2 = window.gameStateManager.getGame(741);
                assertNotNull(game1, 'Original game should remain in state');
                assertNotNull(game2, 'Original game should remain in state');
                assertEqual(game1.name, 'Error Game 1');
                assertEqual(game2.name, 'Error Game 2');
                
                // Cleanup
                games.forEach(game => window.gameStateManager.removeGame(game.id));
                restoreFetch();
            });

            await testRunner.runTest('Batch Refresh: flushBatchRefresh immediate execution', async () => {
                // Add game to state
                const game = { id: 750, name: 'Flush Test Game', console: 'Dreamcast' };
                window.gameStateManager.addGame(game);
                
                // Queue a game for refresh (but don't await)
                window.refreshMultipleGames([750]); // This will be queued
                
                // Mock batch API response
                mockFetch({
                    'POST /api/games/batch-refresh': {
                        ok: true,
                        data: {
                            games: [
                                { id: 750, name: 'Flush Test Game', console: 'Dreamcast', current_price: 55.99 }
                            ],
                            missing_game_ids: [],
                            found_count: 1,
                            missing_count: 0
                        }
                    }
                });

                // Flush immediately
                const results = await window.flushBatchRefresh();
                
                assert(Array.isArray(results), 'Should return array results');
                
                // Verify game was updated immediately
                const updatedGame = window.gameStateManager.getGame(750);
                assertEqual(updatedGame.current_price, 55.99);
                
                // Cleanup
                window.gameStateManager.removeGame(750);
                restoreFetch();
            });
        }

        // Run all tests
        async function runAllTests() {
            testRunner.clear();
            await runUnitTests();
            await runIntegrationTests();
            
            console.log('Test run complete!');
            console.log(`Total: ${testRunner.stats.total}, Passed: ${testRunner.stats.passed}, Failed: ${testRunner.stats.failed}`);
        }

        function clearResults() {
            testRunner.clear();
        }

        // Auto-run tests on load
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Test suite loaded. Click "Run All Tests" to begin.');
        });
    </script>
</body>
</html>