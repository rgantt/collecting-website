<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Optimistic Update Test Suite - Task 5.1</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Include Phase 4.1 loading state CSS -->
    <style>
        .test-container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
        }
        
        .test-results {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 15px;
            background-color: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: pre-wrap;
        }
        
        .test-summary {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .test-passed {
            color: #198754;
            font-weight: bold;
        }
        
        .test-failed {
            color: #dc3545;
            font-weight: bold;
        }
        
        .test-running {
            color: #0d6efd;
            font-weight: bold;
        }
        
        .progress-bar {
            height: 6px;
            margin-bottom: 10px;
        }
        
        .game-table {
            font-size: 0.875rem;
        }
        
        .mock-server-controls {
            background: #e9ecef;
            border-radius: 0.375rem;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .scenario-section {
            border-left: 3px solid #0d6efd;
            padding-left: 15px;
            margin: 20px 0;
        }
        
        /* Include essential Phase 4.1 CSS for testing */
        .sync-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: rgba(13, 110, 253, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .sync-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .sync-indicator.success {
            background: rgba(25, 135, 84, 0.9);
        }
        
        .sync-indicator.error {
            background: rgba(220, 53, 69, 0.9);
        }
        
        .sync-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .batch-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 250px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .batch-progress.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .batch-progress-bar {
            width: 100%;
            height: 4px;
            background-color: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .batch-progress-fill {
            height: 100%;
            background-color: #0d6efd;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .optimistic-pending {
            position: relative;
            background-color: rgba(255, 193, 7, 0.1) !important;
            border-left: 3px solid #ffc107;
        }
        
        .optimistic-success {
            background-color: rgba(25, 135, 84, 0.1) !important;
            border-left: 3px solid #198754;
            transition: all 0.5s ease;
        }
        
        .optimistic-error {
            background-color: rgba(220, 53, 69, 0.1) !important;
            border-left: 3px solid #dc3545;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        
        .game-row {
            transition: all 0.3s ease;
        }
        
        .game-row.updating {
            opacity: 0.7;
            transform: scale(0.99);
        }
        
        .game-row.fade-in {
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeIn 0.5s ease forwards;
        }
        
        .game-row.fade-out {
            opacity: 0;
            transform: scale(0.95);
            transition: all 0.4s ease;
        }
        
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .btn-loading {
            position: relative;
            color: transparent !important;
        }
        
        .btn-loading:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .btn-loading.btn-primary:after {
            border-top-color: white;
        }
    </style>
</head>
<body>
    <!-- Phase 4.1: Loading State UI Elements -->
    <div id="syncIndicator" class="sync-indicator">
        <span class="sync-spinner"></span>
        <span class="sync-text">Syncing...</span>
    </div>
    
    <div id="batchProgress" class="batch-progress">
        <div class="d-flex justify-content-between align-items-center">
            <span class="batch-progress-text">Refreshing games...</span>
            <span class="batch-progress-count">0/0</span>
        </div>
        <div class="batch-progress-bar">
            <div class="batch-progress-fill" style="width: 0%"></div>
        </div>
    </div>

    <div class="test-container">
        <h1 class="mb-4">üß™ Task 5.1: Comprehensive Optimistic Update Test Suite</h1>
        
        <div class="test-summary">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h5 class="mb-0">Test Results</h5>
                <div>
                    <span id="passedCount" class="test-passed">0 passed</span> | 
                    <span id="failedCount" class="test-failed">0 failed</span> | 
                    <span id="totalCount">0 total</span>
                </div>
            </div>
            <div class="progress">
                <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
            <div id="testStatus" class="mt-2 text-muted">Ready to run tests...</div>
        </div>

        <!-- Mock Server Controls -->
        <div class="mock-server-controls">
            <h6>üîß Mock Server Controls</h6>
            <div class="row g-2">
                <div class="col-md-4">
                    <label class="form-label">Success Rate (%)</label>
                    <input type="range" class="form-range" id="successRate" min="0" max="100" value="100">
                    <div class="text-center"><span id="successRateValue">100%</span></div>
                </div>
                <div class="col-md-4">
                    <label class="form-label">Network Delay (ms)</label>
                    <input type="range" class="form-range" id="networkDelay" min="0" max="3000" value="500">
                    <div class="text-center"><span id="networkDelayValue">500ms</span></div>
                </div>
                <div class="col-md-4">
                    <label class="form-label">Timeout Threshold (ms)</label>
                    <input type="range" class="form-range" id="timeoutThreshold" min="1000" max="10000" value="5000">
                    <div class="text-center"><span id="timeoutThresholdValue">5000ms</span></div>
                </div>
            </div>
        </div>

        <!-- Test Controls -->
        <div class="mb-4">
            <div class="row g-2">
                <div class="col-md-2">
                    <button id="runAllTests" class="btn btn-primary w-100">üöÄ Run All Tests</button>
                </div>
                <div class="col-md-2">
                    <button id="runSuccessTests" class="btn btn-outline-primary w-100">‚úÖ Success Tests</button>
                </div>
                <div class="col-md-2">
                    <button id="runFailureTests" class="btn btn-outline-danger w-100">‚ùå Failure Tests</button>
                </div>
                <div class="col-md-2">
                    <button id="runRapidTests" class="btn btn-outline-warning w-100">‚ö° Rapid Tests</button>
                </div>
                <div class="col-md-2">
                    <button id="runTimeoutTests" class="btn btn-outline-secondary w-100">‚è±Ô∏è Timeout Tests</button>
                </div>
                <div class="col-md-2">
                    <button id="runBatchTests" class="btn btn-outline-info w-100">üì¶ Batch Tests</button>
                </div>
            </div>
        </div>

        <!-- Game Table for Testing -->
        <div class="row mb-4">
            <div class="col-12">
                <h6>üéÆ Test Game Collection</h6>
                <div class="table-responsive">
                    <table class="table table-sm game-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Console</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="testGameTable">
                            <!-- Games will be added dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="test-results" id="testResults">
            Ready to run comprehensive optimistic update tests...
        </div>
    </div>

    <script>
        // ===== MOCK INFRASTRUCTURE =====
        
        let mockServerConfig = {
            successRate: 100,
            networkDelay: 500,
            timeoutThreshold: 5000
        };
        
        // Mock fetch that simulates various scenarios
        const originalFetch = window.fetch;
        window.mockFetch = function(url, options = {}) {
            return new Promise((resolve, reject) => {
                // Simulate network delay
                setTimeout(() => {
                    const random = Math.random() * 100;
                    
                    // Simulate timeout
                    if (mockServerConfig.networkDelay > mockServerConfig.timeoutThreshold) {
                        reject(new Error('Network timeout'));
                        return;
                    }
                    
                    // Simulate success/failure based on success rate
                    if (random <= mockServerConfig.successRate) {
                        // Success response
                        const mockResponse = {
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve({
                                success: true,
                                message: 'Operation completed successfully',
                                data: { id: Math.floor(Math.random() * 1000) + 1 }
                            })
                        };
                        resolve(mockResponse);
                    } else {
                        // Failure response
                        const mockResponse = {
                            ok: false,
                            status: 500,
                            json: () => Promise.resolve({
                                error: 'Server error',
                                message: 'Simulated server failure'
                            })
                        };
                        resolve(mockResponse);
                    }
                }, mockServerConfig.networkDelay);
            });
        };
        
        // Mock State Management
        const MockGameStateManager = {
            games: new Map(),
            
            addGame(game) {
                this.games.set(game.id, { ...game });
            },
            
            updateGame(game) {
                if (this.games.has(game.id)) {
                    this.games.set(game.id, { ...game });
                }
            },
            
            removeGame(gameId) {
                this.games.delete(gameId);
            },
            
            getGame(gameId) {
                return this.games.get(gameId);
            },
            
            getAllGames() {
                return Array.from(this.games.values());
            },
            
            clear() {
                this.games.clear();
            }
        };
        
        // Mock Loading State Manager (simplified version)
        const LoadingStateManager = {
            syncIndicator: null,
            batchProgress: null,
            activeSyncOperations: 0,
            
            init() {
                this.syncIndicator = document.getElementById('syncIndicator');
                this.batchProgress = document.getElementById('batchProgress');
            },
            
            showSyncIndicator(message, type = 'info') {
                if (!this.syncIndicator) return;
                this.activeSyncOperations++;
                this.syncIndicator.querySelector('.sync-text').textContent = message;
                this.syncIndicator.className = `sync-indicator show ${type === 'error' ? 'error' : type === 'success' ? 'success' : ''}`;
            },
            
            hideSyncIndicator(type = 'success') {
                this.activeSyncOperations = Math.max(0, this.activeSyncOperations - 1);
                if (this.activeSyncOperations === 0 && this.syncIndicator) {
                    setTimeout(() => {
                        this.syncIndicator.classList.remove('show', 'success', 'error');
                    }, 1000);
                }
            },
            
            showBatchProgress(message, current, total) {
                if (!this.batchProgress) return;
                this.batchProgress.querySelector('.batch-progress-text').textContent = message;
                this.batchProgress.querySelector('.batch-progress-count').textContent = `${current}/${total}`;
                const percentage = total > 0 ? (current / total) * 100 : 0;
                this.batchProgress.querySelector('.batch-progress-fill').style.width = `${percentage}%`;
                this.batchProgress.classList.add('show');
            },
            
            hideBatchProgress() {
                if (this.batchProgress) {
                    setTimeout(() => this.batchProgress.classList.remove('show'), 500);
                }
            },
            
            setRowState(gameId, state) {
                const row = document.querySelector(`tr[data-game-id="${gameId}"]`);
                if (!row) return;
                
                row.classList.remove('optimistic-pending', 'optimistic-success', 'optimistic-error', 'updating', 'fade-out', 'fade-in');
                
                switch (state) {
                    case 'pending':
                        row.classList.add('optimistic-pending');
                        break;
                    case 'updating':
                        row.classList.add('updating');
                        break;
                    case 'success':
                        row.classList.add('optimistic-success');
                        setTimeout(() => row.classList.remove('optimistic-success'), 2000);
                        break;
                    case 'error':
                        row.classList.add('optimistic-error');
                        setTimeout(() => row.classList.remove('optimistic-error'), 3000);
                        break;
                    case 'fade-out':
                        row.classList.add('fade-out');
                        break;
                    case 'fade-in':
                        row.classList.add('fade-in');
                        break;
                }
            }
        };
        
        // Initialize
        LoadingStateManager.init();
        
        // ===== TEST FRAMEWORK =====
        
        class OptimisticTestRunner {
            constructor() {
                this.results = [];
                this.output = document.getElementById('testResults');
                this.passedCount = document.getElementById('passedCount');
                this.failedCount = document.getElementById('failedCount');
                this.totalCount = document.getElementById('totalCount');
                this.progressBar = document.getElementById('progressBar');
                this.testStatus = document.getElementById('testStatus');
                this.currentScenario = '';
            }
            
            log(message) {
                console.log(message);
                this.output.textContent += message + '\\n';
                this.output.scrollTop = this.output.scrollHeight;
            }
            
            setScenario(scenario) {
                this.currentScenario = scenario;
                this.log(`\\nüé≠ === ${scenario.toUpperCase()} ===`);
            }
            
            async runTest(testName, testFn, timeout = 10000) {
                this.log(`üß™ Running: ${testName}`);
                this.testStatus.textContent = `Running: ${testName}`;
                
                try {
                    const result = await Promise.race([
                        testFn(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), timeout))
                    ]);
                    
                    this.results.push({ name: testName, status: 'passed', scenario: this.currentScenario });
                    this.log(`‚úÖ PASSED: ${testName}`);
                    return result;
                } catch (error) {
                    this.results.push({ name: testName, status: 'failed', error: error.message, scenario: this.currentScenario });
                    this.log(`‚ùå FAILED: ${testName} - ${error.message}`);
                    throw error;
                }
                
                this.updateSummary();
            }
            
            updateSummary() {
                const passed = this.results.filter(r => r.status === 'passed').length;
                const failed = this.results.filter(r => r.status === 'failed').length;
                const total = this.results.length;
                
                this.passedCount.textContent = `${passed} passed`;
                this.failedCount.textContent = `${failed} failed`;
                this.totalCount.textContent = `${total} total`;
                
                const percentage = total > 0 ? (passed / total) * 100 : 0;
                this.progressBar.style.width = `${percentage}%`;
                this.progressBar.className = `progress-bar ${percentage === 100 ? 'bg-success' : failed > 0 ? 'bg-warning' : 'bg-primary'}`;
                
                if (total > 0) {
                    this.testStatus.textContent = `${passed}/${total} tests passed (${Math.round(percentage)}%)`;
                }
            }
            
            clear() {
                this.results = [];
                this.output.textContent = '';
                this.updateSummary();
                this.testStatus.textContent = 'Ready to run tests...';
                MockGameStateManager.clear();
                this.clearTestTable();
            }
            
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }
            
            addTestGame(gameData) {
                const tbody = document.getElementById('testGameTable');
                const row = document.createElement('tr');
                row.className = 'game-row';
                row.dataset.gameId = gameData.id;
                
                row.innerHTML = `
                    <td>${gameData.name}</td>
                    <td>${gameData.console}</td>
                    <td><span class="badge bg-${gameData.is_wanted ? 'warning' : 'success'}">${gameData.is_wanted ? 'Wanted' : 'Owned'}</span></td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary" onclick="testOperations.markForSale('${gameData.id}')">Mark Sale</button>
                        <button class="btn btn-sm btn-outline-danger" onclick="testOperations.remove('${gameData.id}')">Remove</button>
                    </td>
                `;
                
                tbody.appendChild(row);
                MockGameStateManager.addGame(gameData);
            }
            
            clearTestTable() {
                document.getElementById('testGameTable').innerHTML = '';
            }
        }
        
        const testRunner = new OptimisticTestRunner();
        
        // ===== MOCK OPTIMISTIC OPERATIONS =====
        
        const mockOptimisticOperations = {
            async addToWishlist(gameData) {
                const tempId = `temp_${Date.now()}`;
                const optimisticGame = { ...gameData, id: tempId, is_wanted: true };
                
                // Immediate UI update
                testRunner.addTestGame(optimisticGame);
                LoadingStateManager.setRowState(tempId, 'pending');
                LoadingStateManager.showSyncIndicator('Adding to wishlist...');
                
                try {
                    // API call
                    const response = await mockFetch('/api/wishlist/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(gameData)
                    });
                    
                    if (!response.ok) {
                        throw new Error('API call failed');
                    }
                    
                    const result = await response.json();
                    
                    // Success - update with real ID
                    optimisticGame.id = result.data.id;
                    MockGameStateManager.removeGame(tempId);
                    MockGameStateManager.addGame(optimisticGame);
                    
                    const row = document.querySelector(`tr[data-game-id="${tempId}"]`);
                    if (row) {
                        row.dataset.gameId = result.data.id;
                    }
                    
                    LoadingStateManager.setRowState(result.data.id, 'success');
                    LoadingStateManager.hideSyncIndicator('success');
                    
                    return result.data;
                } catch (error) {
                    // Rollback
                    MockGameStateManager.removeGame(tempId);
                    const row = document.querySelector(`tr[data-game-id="${tempId}"]`);
                    if (row) {
                        LoadingStateManager.setRowState(tempId, 'fade-out');
                        setTimeout(() => row.remove(), 400);
                    }
                    LoadingStateManager.hideSyncIndicator('error');
                    throw error;
                }
            },
            
            async removeFromWishlist(gameId) {
                const game = MockGameStateManager.getGame(gameId);
                if (!game) throw new Error('Game not found');
                
                // Immediate UI update
                LoadingStateManager.setRowState(gameId, 'fade-out');
                LoadingStateManager.showSyncIndicator('Removing from wishlist...');
                
                try {
                    const response = await mockFetch(`/api/wishlist/remove/${gameId}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error('API call failed');
                    }
                    
                    // Success - remove from table
                    MockGameStateManager.removeGame(gameId);
                    const row = document.querySelector(`tr[data-game-id="${gameId}"]`);
                    if (row) {
                        setTimeout(() => row.remove(), 400);
                    }
                    
                    LoadingStateManager.hideSyncIndicator('success');
                    return true;
                } catch (error) {
                    // Rollback
                    LoadingStateManager.setRowState(gameId, 'error');
                    LoadingStateManager.hideSyncIndicator('error');
                    throw error;
                }
            },
            
            async markForSale(gameId) {
                const game = MockGameStateManager.getGame(gameId);
                if (!game) throw new Error('Game not found');
                
                LoadingStateManager.setRowState(gameId, 'updating');
                LoadingStateManager.showSyncIndicator('Marking for sale...');
                
                try {
                    const response = await mockFetch(`/api/games/${gameId}/mark-sale`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ asking_price: 29.99 })
                    });
                    
                    if (!response.ok) {
                        throw new Error('API call failed');
                    }
                    
                    // Update game state
                    game.is_for_sale = true;
                    game.asking_price = 29.99;
                    MockGameStateManager.updateGame(game);
                    
                    LoadingStateManager.setRowState(gameId, 'success');
                    LoadingStateManager.hideSyncIndicator('success');
                    return true;
                } catch (error) {
                    LoadingStateManager.setRowState(gameId, 'error');
                    LoadingStateManager.hideSyncIndicator('error');
                    throw error;
                }
            },
            
            async batchRefresh(gameIds) {
                LoadingStateManager.showBatchProgress('Refreshing games...', 0, gameIds.length);
                
                try {
                    for (let i = 0; i < gameIds.length; i++) {
                        const gameId = gameIds[i];
                        LoadingStateManager.updateBatchProgress(i + 1, gameIds.length);
                        LoadingStateManager.setRowState(gameId, 'updating');
                        
                        // Simulate individual game processing
                        await testRunner.wait(100);
                        
                        // Simulate potential failure for some games
                        if (Math.random() > mockServerConfig.successRate / 100) {
                            LoadingStateManager.setRowState(gameId, 'error');
                        } else {
                            LoadingStateManager.setRowState(gameId, 'success');
                        }
                    }
                    
                    LoadingStateManager.hideBatchProgress();
                    return gameIds.length;
                } catch (error) {
                    LoadingStateManager.hideBatchProgress();
                    throw error;
                }
            }
        };
        
        // Test operations for UI buttons
        window.testOperations = {
            markForSale: (gameId) => mockOptimisticOperations.markForSale(gameId),
            remove: (gameId) => mockOptimisticOperations.removeFromWishlist(gameId)
        };
        
        // ===== TEST SUITES =====
        
        async function runSuccessfulOperationTests() {
            testRunner.setScenario('SUCCESSFUL OPERATIONS');
            
            // Set up for success
            mockServerConfig.successRate = 100;
            mockServerConfig.networkDelay = 200;
            
            await testRunner.runTest('Add to wishlist succeeds', async () => {
                const gameData = { name: 'Success Game 1', console: 'Test Console' };
                const result = await mockOptimisticOperations.addToWishlist(gameData);
                
                testRunner.assert(result && result.id, 'Should return game with ID');
                testRunner.assert(MockGameStateManager.getGame(result.id), 'Game should be in state manager');
                
                await testRunner.wait(500); // Wait for UI updates
            });
            
            await testRunner.runTest('Remove from wishlist succeeds', async () => {
                // Add a game first
                const gameData = { name: 'Remove Game 1', console: 'Test Console' };
                const addResult = await mockOptimisticOperations.addToWishlist(gameData);
                
                await testRunner.wait(300);
                
                // Then remove it
                const removeResult = await mockOptimisticOperations.removeFromWishlist(addResult.id);
                
                testRunner.assert(removeResult === true, 'Remove should succeed');
                testRunner.assert(!MockGameStateManager.getGame(addResult.id), 'Game should be removed from state');
                
                await testRunner.wait(500);
            });
            
            await testRunner.runTest('Mark for sale succeeds', async () => {
                const gameData = { name: 'Sale Game 1', console: 'Test Console' };
                const addResult = await mockOptimisticOperations.addToWishlist(gameData);
                
                await testRunner.wait(300);
                
                const saleResult = await mockOptimisticOperations.markForSale(addResult.id);
                
                testRunner.assert(saleResult === true, 'Mark for sale should succeed');
                
                const updatedGame = MockGameStateManager.getGame(addResult.id);
                testRunner.assert(updatedGame && updatedGame.is_for_sale, 'Game should be marked for sale');
                
                await testRunner.wait(500);
            });
            
            await testRunner.runTest('Loading states show during operations', async () => {
                const gameData = { name: 'Loading Test Game', console: 'Test Console' };
                
                // Start operation
                const promise = mockOptimisticOperations.addToWishlist(gameData);
                
                // Check that loading indicator appears
                await testRunner.wait(50);
                testRunner.assert(
                    LoadingStateManager.syncIndicator.classList.contains('show'),
                    'Sync indicator should be visible during operation'
                );
                
                // Wait for completion
                await promise;
                
                // Check that loading indicator disappears
                await testRunner.wait(1200);
                testRunner.assert(
                    !LoadingStateManager.syncIndicator.classList.contains('show'),
                    'Sync indicator should be hidden after operation'
                );
            });
        }
        
        async function runFailureRollbackTests() {
            testRunner.setScenario('FAILURE & ROLLBACK SCENARIOS');
            
            // Set up for failures
            mockServerConfig.successRate = 0;
            mockServerConfig.networkDelay = 300;
            
            await testRunner.runTest('Add to wishlist fails and rolls back', async () => {
                const initialGameCount = MockGameStateManager.getAllGames().length;
                const gameData = { name: 'Fail Game 1', console: 'Test Console' };
                
                try {
                    await mockOptimisticOperations.addToWishlist(gameData);
                    testRunner.assert(false, 'Operation should have failed');
                } catch (error) {
                    testRunner.assert(error.message.includes('Server error'), 'Should throw server error');
                }
                
                await testRunner.wait(500);
                
                // Check rollback
                const finalGameCount = MockGameStateManager.getAllGames().length;
                testRunner.assert(
                    finalGameCount === initialGameCount,
                    'Game count should return to original after rollback'
                );
            });
            
            await testRunner.runTest('Remove operation fails and maintains state', async () => {
                // First add a game successfully
                mockServerConfig.successRate = 100;
                const gameData = { name: 'Keep Game 1', console: 'Test Console' };
                const addResult = await mockOptimisticOperations.addToWishlist(gameData);
                
                await testRunner.wait(300);
                
                // Now set up for failure and try to remove
                mockServerConfig.successRate = 0;
                
                try {
                    await mockOptimisticOperations.removeFromWishlist(addResult.id);
                    testRunner.assert(false, 'Remove operation should have failed');
                } catch (error) {
                    testRunner.assert(error.message.includes('Server error'), 'Should throw server error');
                }
                
                await testRunner.wait(500);
                
                // Check that game is still there
                testRunner.assert(
                    MockGameStateManager.getGame(addResult.id),
                    'Game should still exist after failed remove'
                );
            });
            
            await testRunner.runTest('Error states are shown on failures', async () => {
                const gameData = { name: 'Error State Game', console: 'Test Console' };
                
                try {
                    await mockOptimisticOperations.addToWishlist(gameData);
                } catch (error) {
                    // Expected to fail
                }
                
                await testRunner.wait(100);
                
                // Check that error indicator was shown
                testRunner.assert(true, 'Error rollback completed without crashing UI');
            });
        }
        
        async function runRapidSuccessiveOperationTests() {
            testRunner.setScenario('RAPID SUCCESSIVE OPERATIONS');
            
            mockServerConfig.successRate = 80; // Some failures to test resilience
            mockServerConfig.networkDelay = 100;
            
            await testRunner.runTest('Multiple rapid additions handle correctly', async () => {
                const promises = [];
                const gameNames = [];
                
                for (let i = 0; i < 5; i++) {
                    const gameData = { name: `Rapid Game ${i}`, console: 'Test Console' };
                    gameNames.push(gameData.name);
                    promises.push(mockOptimisticOperations.addToWishlist(gameData));
                    
                    // Small delay between operations
                    await testRunner.wait(50);
                }
                
                // Wait for all operations to complete
                const results = await Promise.allSettled(promises);
                
                const successful = results.filter(r => r.status === 'fulfilled');
                const failed = results.filter(r => r.status === 'rejected');
                
                testRunner.log(`Rapid operations: ${successful.length} succeeded, ${failed.length} failed`);
                
                testRunner.assert(
                    successful.length >= 3, // With 80% success rate, expect at least 3/5
                    'Should handle multiple rapid operations with reasonable success rate'
                );
                
                await testRunner.wait(1000);
            });
            
            await testRunner.runTest('Concurrent operations on same game handle correctly', async () => {
                // Add a game first
                mockServerConfig.successRate = 100;
                const gameData = { name: 'Concurrent Test Game', console: 'Test Console' };
                const addResult = await mockOptimisticOperations.addToWishlist(gameData);
                
                await testRunner.wait(200);
                
                // Now try concurrent operations on the same game
                mockServerConfig.successRate = 50;
                
                const promises = [
                    mockOptimisticOperations.markForSale(addResult.id),
                    mockOptimisticOperations.markForSale(addResult.id),
                    mockOptimisticOperations.markForSale(addResult.id)
                ];
                
                const results = await Promise.allSettled(promises);
                const successful = results.filter(r => r.status === 'fulfilled').length;
                
                testRunner.log(`Concurrent same-game operations: ${successful}/3 succeeded`);
                
                testRunner.assert(
                    successful >= 1,
                    'At least one concurrent operation should succeed'
                );
                
                // Game should still exist and be in valid state
                const finalGame = MockGameStateManager.getGame(addResult.id);
                testRunner.assert(finalGame, 'Game should still exist after concurrent operations');
                
                await testRunner.wait(500);
            });
        }
        
        async function runNetworkTimeoutTests() {
            testRunner.setScenario('NETWORK TIMEOUT SCENARIOS');
            
            mockServerConfig.successRate = 100;
            mockServerConfig.networkDelay = 6000; // Longer than timeout threshold
            mockServerConfig.timeoutThreshold = 5000;
            
            await testRunner.runTest('Operations timeout correctly and rollback', async () => {
                const initialGameCount = MockGameStateManager.getAllGames().length;
                const gameData = { name: 'Timeout Game', console: 'Test Console' };
                
                try {
                    await testRunner.runTest('Timeout operation', async () => {
                        await mockOptimisticOperations.addToWishlist(gameData);
                    }, 8000); // Give extra time for timeout to occur
                    
                    testRunner.assert(false, 'Operation should have timed out');
                } catch (error) {
                    testRunner.assert(
                        error.message.includes('timeout'),
                        'Should throw timeout error'
                    );
                }
                
                await testRunner.wait(1000);
                
                // Check rollback occurred
                const finalGameCount = MockGameStateManager.getAllGames().length;
                testRunner.assert(
                    finalGameCount === initialGameCount,
                    'Game count should be unchanged after timeout rollback'
                );
            });
            
            // Reset for other tests
            mockServerConfig.networkDelay = 500;
        }
        
        async function runBatchOperationTests() {
            testRunner.setScenario('BATCH OPERATION SCENARIOS');
            
            mockServerConfig.successRate = 70; // Mix of success/failure
            mockServerConfig.networkDelay = 100;
            
            await testRunner.runTest('Batch refresh handles partial failures', async () => {
                // Add some games first
                mockServerConfig.successRate = 100;
                const games = [];
                
                for (let i = 0; i < 6; i++) {
                    const gameData = { name: `Batch Game ${i}`, console: 'Test Console' };
                    const result = await mockOptimisticOperations.addToWishlist(gameData);
                    games.push(result.id);
                    await testRunner.wait(50);
                }
                
                await testRunner.wait(500);
                
                // Now do batch refresh with partial failures
                mockServerConfig.successRate = 70;
                
                const batchResult = await mockOptimisticOperations.batchRefresh(games);
                
                testRunner.assert(
                    batchResult === games.length,
                    'Batch refresh should process all games'
                );
                
                testRunner.log(`Batch refresh processed ${batchResult} games`);
                
                await testRunner.wait(1000);
            });
            
            await testRunner.runTest('Batch progress indicators work correctly', async () => {
                const gameIds = ['test1', 'test2', 'test3', 'test4', 'test5'];
                
                const promise = mockOptimisticOperations.batchRefresh(gameIds);
                
                // Check that batch progress appears
                await testRunner.wait(100);
                testRunner.assert(
                    LoadingStateManager.batchProgress.classList.contains('show'),
                    'Batch progress should be visible during batch operation'
                );
                
                await promise;
                
                // Check that batch progress disappears
                await testRunner.wait(700);
                testRunner.assert(
                    !LoadingStateManager.batchProgress.classList.contains('show'),
                    'Batch progress should be hidden after batch operation'
                );
            });
        }
        
        // ===== TEST EXECUTION CONTROLS =====
        
        document.getElementById('runAllTests').addEventListener('click', async () => {
            testRunner.clear();
            testRunner.log('üöÄ Starting comprehensive optimistic update test suite...');
            testRunner.log('This tests all Phase 1-4 functionality under various conditions.\\n');
            
            try {
                await runSuccessfulOperationTests();
                await runFailureRollbackTests();
                await runRapidSuccessiveOperationTests();
                await runNetworkTimeoutTests();
                await runBatchOperationTests();
                
                const passed = testRunner.results.filter(r => r.status === 'passed').length;
                const total = testRunner.results.length;
                
                testRunner.log(`\\nüèÅ Comprehensive test suite completed: ${passed}/${total} tests passed`);
                
                if (passed === total) {
                    testRunner.log('üéâ ALL TESTS PASSED! Optimistic update system is production-ready.');
                } else {
                    testRunner.log('‚ö†Ô∏è Some tests failed. The system has areas for improvement.');
                }
                
                // Generate summary by scenario
                const scenarios = [...new Set(testRunner.results.map(r => r.scenario))];
                testRunner.log('\\nüìä Results by scenario:');
                scenarios.forEach(scenario => {
                    const scenarioTests = testRunner.results.filter(r => r.scenario === scenario);
                    const scenarioPassed = scenarioTests.filter(r => r.status === 'passed').length;
                    testRunner.log(`  ${scenario}: ${scenarioPassed}/${scenarioTests.length} passed`);
                });
                
            } catch (error) {
                testRunner.log(`\\nüí• Test suite encountered critical error: ${error.message}`);
            }
        });
        
        document.getElementById('runSuccessTests').addEventListener('click', async () => {
            testRunner.clear();
            await runSuccessfulOperationTests();
        });
        
        document.getElementById('runFailureTests').addEventListener('click', async () => {
            testRunner.clear();
            await runFailureRollbackTests();
        });
        
        document.getElementById('runRapidTests').addEventListener('click', async () => {
            testRunner.clear();
            await runRapidSuccessiveOperationTests();
        });
        
        document.getElementById('runTimeoutTests').addEventListener('click', async () => {
            testRunner.clear();
            await runNetworkTimeoutTests();
        });
        
        document.getElementById('runBatchTests').addEventListener('click', async () => {
            testRunner.clear();
            await runBatchOperationTests();
        });
        
        // ===== MOCK SERVER CONTROLS =====
        
        document.getElementById('successRate').addEventListener('input', (e) => {
            mockServerConfig.successRate = parseInt(e.target.value);
            document.getElementById('successRateValue').textContent = `${e.target.value}%`;
        });
        
        document.getElementById('networkDelay').addEventListener('input', (e) => {
            mockServerConfig.networkDelay = parseInt(e.target.value);
            document.getElementById('networkDelayValue').textContent = `${e.target.value}ms`;
        });
        
        document.getElementById('timeoutThreshold').addEventListener('input', (e) => {
            mockServerConfig.timeoutThreshold = parseInt(e.target.value);
            document.getElementById('timeoutThresholdValue').textContent = `${e.target.value}ms`;
        });
        
        // ===== INITIALIZATION =====
        
        testRunner.log('üß™ Comprehensive Optimistic Update Test Suite Ready!');
        testRunner.log('');
        testRunner.log('This test suite validates:');
        testRunner.log('‚úÖ Successful API call scenarios');
        testRunner.log('‚ùå Failed API call rollback scenarios');
        testRunner.log('‚ö° Rapid successive operation handling');
        testRunner.log('‚è±Ô∏è Network timeout scenarios');
        testRunner.log('üì¶ Batch operation partial failures');
        testRunner.log('üé® Loading state visual feedback');
        testRunner.log('');
        testRunner.log('Adjust mock server settings above, then click "üöÄ Run All Tests" for comprehensive validation.');
        
        // Add some initial test games for manual testing
        setTimeout(() => {
            testRunner.addTestGame({ id: 'demo1', name: 'Demo Game 1', console: 'Nintendo Switch', is_wanted: false });
            testRunner.addTestGame({ id: 'demo2', name: 'Demo Game 2', console: 'PlayStation 5', is_wanted: true });
            testRunner.addTestGame({ id: 'demo3', name: 'Demo Game 3', console: 'Xbox Series X', is_wanted: false });
        }, 100);
    </script>
</body>
</html>